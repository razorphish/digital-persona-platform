# Dynamic Configuration System

This project uses a fully dynamic configuration system that eliminates hardcoding across all scripts, workflows, and Terraform configurations. The system automatically adapts to different environments, domains, regions, and project settings.

## üéØ Overview

The dynamic configuration system provides:

- **Zero Hardcoding**: All domains, regions, and resource names are dynamically generated
- **Environment Detection**: Automatic detection from git branches, directory names, or explicit settings
- **Cross-Platform Consistency**: Same configuration used across scripts, workflows, and Terraform
- **Multi-Domain Support**: Easy switching between different base domains
- **Region Flexibility**: Support for any AWS region with automatic resource discovery

## üìÅ Configuration Files

### Core Configuration

- `scripts/config/environment.sh` - Central configuration script sourced by all shell scripts
- `terraform/shared-variables.tf` - Shared Terraform variables and validation rules
- `.github/workflows/deploy-serverless.yml` - Uses environment variables for all dynamic values

## üîß Environment Variables

### Primary Configuration

```bash
# Domain Configuration
BASE_DOMAIN="hibiji.com"           # Can be overridden for different projects
DOMAIN_NAME="$BASE_DOMAIN"         # Alias for base domain

# AWS Configuration
AWS_REGION="us-west-1"             # Primary AWS region (auto-detected from AWS CLI)
AWS_CERT_REGION="us-east-1"        # SSL certificate region (required for CloudFront)
AWS_ACCOUNT_ID="(auto-detected)"   # AWS account ID (auto-detected via STS)

# Project Configuration
PROJECT_NAME="dpp"                 # Project name for resource prefixes
ORGANIZATION_NAME="hibiji"         # Organization name for tagging and naming
```

### Environment Detection

```bash
ENVIRONMENT="dev01"                # Auto-detected or explicitly set
MAIN_ENV="dev"                     # Extracted main environment (dev, qa, staging, prod)
SUB_ENV="01"                       # Extracted sub-environment number
SUB_ENVIRONMENT="dev01"            # Full sub-environment identifier
```

## üöÄ Usage

### Shell Scripts

All shell scripts automatically load the dynamic configuration:

```bash
# Automatic loading in all scripts
source "$(dirname "$0")/config/environment.sh"

# Then use dynamic variables
echo "Website URL: $FRONTEND_URL"
echo "API URL: $API_URL"
echo "Resource Prefix: $RESOURCE_PREFIX"
```

### GitHub Workflows

Workflows use environment variables defined at the top level:

```yaml
env:
  AWS_REGION: us-west-1
  BASE_DOMAIN: hibiji.com
  PROJECT_NAME: dpp
# Later used as: ${BASE_DOMAIN}, ${{ env.AWS_REGION }}, etc.
```

### Terraform

Variables are defined in `terraform/shared-variables.tf` and passed via `.tfvars`:

```hcl
# Generated by workflow in environment.auto.tfvars
environment = "dev"
sub_environment = "dev01"
domain_name = "hibiji.com"
aws_region = "us-west-1"
project_name = "dpp"
```

## üåê Dynamic Domain Generation

The system generates domains based on environment:

### Development/QA/Staging

- **Website**: `{sub_environment}.{base_domain}` ‚Üí `dev01.hibiji.com`
- **API**: `{sub_environment}-api.{base_domain}` ‚Üí `dev01-api.hibiji.com`

### Production

- **Website**: `www.{base_domain}` ‚Üí `www.hibiji.com`
- **API**: `api.{base_domain}` ‚Üí `api.hibiji.com`

## üèóÔ∏è Resource Naming Convention

All AWS resources follow a consistent naming pattern:

```
{main_env}-{sub_environment}-{project_name}-{resource_type}

Examples:
- Lambda: dev-dev01-dpp-api
- S3 Bucket: dev-dev01-dpp-website
- ECR Repo: dev-dev01-dpp-ml-service
- IAM Role: dev-dev01-dpp-lambda-execution
```

## üîç Environment Detection Logic

The system automatically detects the environment using this priority:

1. **Explicit Setting**: `ENVIRONMENT` environment variable
2. **Git Branch**: Extracts from current git branch (dev01, qa03, staging02, etc.)
3. **Directory Name**: Uses directory name if it matches pattern
4. **Default**: Falls back to `dev01`

### Supported Environment Patterns

- `dev01-dev99`: Development environments
- `qa01-qa99`: QA environments
- `staging01-staging99`: Staging environments
- `hotfix01-hotfix99`: Hotfix environments
- `main`: Production environment
- `prod`: Production environment

## üõ†Ô∏è Override Configuration

### For Different Domains

```bash
export BASE_DOMAIN="mycompany.com"
./scripts/validate-deployment.sh
# Will use mycompany.com instead of hibiji.com
```

### For Different Regions

```bash
export AWS_REGION="eu-west-1"
./scripts/deploy-serverless.sh
# Will deploy to eu-west-1 instead of us-west-1
```

### For Different Projects

```bash
export PROJECT_NAME="myproject"
export ORGANIZATION_NAME="myorg"
./scripts/deploy-serverless.sh
# Will use myproject resource names
```

## üìã Examples

### Script Usage

```bash
# All these work dynamically based on environment detection
./scripts/validate-deployment.sh        # Uses current git branch
./scripts/dynamic-cleanup-environment.sh qa03   # Explicit environment
ENVIRONMENT=staging02 ./scripts/deploy-serverless.sh  # Override via env var
```

### Workflow Dispatch

```bash
# GitHub Actions workflow automatically detects from branch
gh workflow run deploy-serverless.yml --ref dev01

# Or specify different environment via inputs (if configured)
gh workflow run deploy-serverless.yml -f environment=qa03
```

### Terraform Direct Usage

```bash
cd terraform/environments/dev
terraform apply -var="domain_name=mycompany.com" -var="aws_region=eu-west-1"
```

## üîê Security Considerations

### Sensitive Values

- AWS credentials are never hardcoded
- Domain names are configurable but default to known values
- Account IDs are auto-detected to prevent misconfiguration

### Validation

- All Terraform variables include validation rules
- Invalid environment names are rejected
- Domain format is validated
- AWS region format is validated

## üß™ Testing Dynamic Configuration

### Test Environment Detection

```bash
# Test various environment patterns
cd /tmp
git init
git checkout -b qa05
source scripts/config/environment.sh
print_environment_info
# Should show: Environment: qa05 (main: qa, sub: 05)
```

### Test Domain Generation

```bash
export BASE_DOMAIN="test.com"
export ENVIRONMENT="staging02"
source scripts/config/environment.sh
echo "Website: $WEBSITE_DOMAIN"  # Should show: staging02.test.com
echo "API: $API_DOMAIN"          # Should show: staging02-api.test.com
```

### Test Resource Discovery

```bash
# Test AWS resource discovery (requires AWS CLI configured)
source scripts/config/environment.sh
echo "Account ID: $AWS_ACCOUNT_ID"
echo "API Gateway ID: $API_GATEWAY_ID"
echo "Hosted Zone ID: $HOSTED_ZONE_ID"
```

## üö® Migration from Hardcoded Values

If updating from previous hardcoded versions:

1. **Remove hardcoded values** from any custom scripts
2. **Source the configuration** at the top of shell scripts:
   ```bash
   source "$(dirname "$0")/config/environment.sh"
   ```
3. **Update variable references** to use dynamic values:
   ```bash
   # Old: curl https://dev01.hibiji.com
   # New: curl "$FRONTEND_URL"
   ```
4. **Test with different environments** to ensure dynamic behavior works

## üìà Benefits

### Development Efficiency

- **One-time setup**: Configuration works for all environments
- **No manual updates**: Environment changes automatically propagate
- **Consistent naming**: All resources follow same patterns
- **Easy testing**: Switch between environments instantly

### Infrastructure as Code

- **No hardcoding**: All values are configurable
- **Environment parity**: Same configuration across all environments
- **Version control**: All configuration is tracked in git
- **Reproducible**: Deployments are consistent and repeatable

### Operations

- **Multi-region support**: Easy deployment to different AWS regions
- **Multi-domain support**: Support multiple domains/projects
- **Automated discovery**: Resources are found automatically
- **Clear debugging**: Environment information is always visible

This dynamic configuration system ensures that the infrastructure is truly portable, maintainable, and follows Infrastructure as Code best practices.
