name: Digital Persona Platform - Unified CI/CD (Optimized)

on:
  push:
    branches:
      - main
      - "dev[0-9][0-9]"
      - "qa[0-9][0-9]"
      - "staging[0-9][0-9]"
      - "hotfix[0-9][0-9]"
  pull_request:
    branches:
      - main
      - "dev[0-9][0-9]"
      - "qa[0-9][0-9]"
      - "staging[0-9][0-9]"
      - "hotfix[0-9][0-9]"
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force deployment even if tests fail"
        required: false
        default: false
        type: boolean
      skip_tests:
        description: "Skip test execution for emergency deployments"
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  security-events: write
  actions: read
  contents: read

env:
  AWS_REGION: us-west-1
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "18"
  DOMAIN: hibiji.com
  TERRAFORM_VERSION: "1.5.0"

# Prevent multiple runs from conflicting
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ===========================================
  # VALIDATION PHASE (Runs First)
  # ===========================================

  detect-environment:
    name: ğŸ” Environment Detection
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      main_env: ${{ steps.env.outputs.main_env }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
      is_numbered_env: ${{ steps.env.outputs.is_numbered_env }}
      ecr_registry: ${{ steps.env.outputs.ecr_registry }}
    steps:
      - name: Determine Environment and AWS Registry
        id: env
        run: |
          # Determine environment based on branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prod"
            MAIN_ENV="prod"
            SHOULD_DEPLOY="false"  # Main branch requires manual deployment
            IS_NUMBERED_ENV="false"
          elif [[ "${{ github.ref_name }}" =~ ^dev[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="dev"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          elif [[ "${{ github.ref_name }}" =~ ^qa[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="qa"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          elif [[ "${{ github.ref_name }}" =~ ^staging[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="staging"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          elif [[ "${{ github.ref_name }}" =~ ^hotfix[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="hotfix"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          else
            echo "âŒ Invalid branch name: ${{ github.ref_name }}"
            echo "âŒ Only these formats are allowed: dev##, qa##, staging##, hotfix##, main"
            exit 1
          fi

          # Set ECR registry for later use
          ECR_REGISTRY="570827307849.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "main_env=$MAIN_ENV" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "is_numbered_env=$IS_NUMBERED_ENV" >> $GITHUB_OUTPUT
          echo "ecr_registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT

          echo "ğŸ¯ Environment: $ENVIRONMENT"
          echo "ğŸ—ï¸  Main Environment: $MAIN_ENV"
          echo "ğŸš€ Should Deploy: $SHOULD_DEPLOY"
          echo "ğŸ”— ECR Registry: $ECR_REGISTRY"

  # ===========================================
  # PARALLEL CI PHASE (All run simultaneously)
  # ===========================================

  security-scan:
    name: ğŸ›¡ï¸ Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache security scan results
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/trivy
            ~/.cache/trufflehog
          key: ${{ runner.os }}-security-${{ hashFiles('**/requirements.txt', '**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-security-

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: Run TruffleHog secret scanner
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.sha || github.event.before }}
          head: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || github.sha }}
          extra_args: --debug --only-verified

      - name: Upload security scan artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results
          path: |
            trivy-results.sarif
          retention-days: 30

  backend-tests:
    name: ğŸ Backend Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: github.event.inputs.skip_tests != 'true'
    strategy:
      matrix:
        python-version: ["3.11"]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.cache/pytest
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}-${{ matrix.python-version }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}-
            ${{ runner.os }}-pip-

      - name: Install dependencies with retry
        run: |
          python -m pip install --upgrade pip
          # Retry pip install up to 3 times
          for i in {1..3}; do
            pip install -r requirements.txt && break
            echo "Pip install attempt $i failed, retrying..."
            sleep 5
          done
          pip install pytest pytest-cov pytest-asyncio pytest-xdist

      - name: Run backend tests with coverage
        run: |
          python -m pytest tests/ -v \
            --cov=app \
            --cov-report=xml \
            --cov-report=term-missing \
            --maxfail=5 \
            -n auto \
            --tb=short \
            --strict-markers

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        if: always()
        with:
          file: ./coverage.xml
          flags: backend
          name: backend-coverage-${{ matrix.python-version }}
          fail_ci_if_error: false

      - name: Upload backend test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-test-results-${{ matrix.python-version }}
          path: |
            coverage.xml
            .coverage
            pytest.xml
          retention-days: 30

  frontend-tests:
    name: âš›ï¸ Frontend Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event.inputs.skip_tests != 'true'
    defaults:
      run:
        working-directory: frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies with retry
        run: |
          # Retry npm ci up to 3 times
          for i in {1..3}; do
            npm ci && break
            echo "npm ci attempt $i failed, retrying..."
            sleep 5
          done

      - name: Run ESLint
        run: npm run lint --if-present || echo "ESLint not configured"

      - name: Run frontend tests
        run: |
          npm test -- --coverage --watchAll=false --verbose --maxWorkers=2

      - name: Upload frontend test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-test-results
          path: |
            frontend/coverage/
            frontend/test-results.xml
          retention-days: 30

  dependency-scan:
    name: ğŸ“¦ Dependency Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip for dependency scanning
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-safety-${{ hashFiles('**/requirements.txt') }}

      - name: Install safety
        run: pip install safety

      - name: Run Python dependency security scan
        run: |
          pip install -r requirements.txt
          safety check --json > python-safety-report.json || true
          safety check || echo "Python dependency vulnerabilities found"

      - name: Set up Node.js for npm audit
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Run npm audit
        working-directory: frontend
        run: |
          npm ci
          npm audit --audit-level=moderate --json > ../npm-audit-report.json || true
          npm audit --audit-level=moderate || echo "npm vulnerabilities found"

      - name: Upload dependency scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dependency-scan-results
          path: |
            python-safety-report.json
            npm-audit-report.json
          retention-days: 30

  build-and-package:
    name: ğŸ—ï¸ Build & Package
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [detect-environment]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: false
          tags: |
            ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:${{ github.sha }}
            ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      - name: Build frontend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          platforms: linux/amd64
          push: false
          tags: |
            ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:${{ github.sha }}
            ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Create build artifacts
        run: |
          mkdir -p dist
          echo "Build completed for environment: ${{ needs.detect-environment.outputs.environment }}" > dist/build-info.txt
          echo "Commit SHA: ${{ github.sha }}" >> dist/build-info.txt
          echo "Build timestamp: $(date -u)" >> dist/build-info.txt

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ needs.detect-environment.outputs.environment }}
          path: dist/
          retention-days: 30

  terraform-plan:
    name: ğŸ—ï¸ Terraform Plan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [detect-environment]
    if: needs.detect-environment.outputs.is_numbered_env == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Ensure Terraform prerequisites exist
        run: |
          echo "ğŸ”§ Ensuring Terraform prerequisites exist..."

          # Create S3 bucket for Terraform state if it doesn't exist
          BUCKET_NAME="hibiji-terraform-state"
          if ! aws s3 ls "s3://$BUCKET_NAME" 2>/dev/null; then
            echo "Creating S3 bucket for Terraform state..."
            aws s3 mb "s3://$BUCKET_NAME" --region ${{ env.AWS_REGION }}
            
            # Enable versioning
            aws s3api put-bucket-versioning \
              --bucket "$BUCKET_NAME" \
              --versioning-configuration Status=Enabled
            
            # Enable encryption
            aws s3api put-bucket-encryption \
              --bucket "$BUCKET_NAME" \
              --server-side-encryption-configuration '{
                "Rules": [
                  {
                    "ApplyServerSideEncryptionByDefault": {
                      "SSEAlgorithm": "AES256"
                    }
                  }
                ]
              }'
            
            # Add tags
            aws s3api put-bucket-tagging \
              --bucket "$BUCKET_NAME" \
              --tagging 'TagSet=[
                {Key=Project,Value=hibiji},
                {Key=Purpose,Value=terraform-state},
                {Key=ManagedBy,Value=github-actions}
              ]'
            
            echo "âœ… S3 bucket '$BUCKET_NAME' created with versioning and encryption"
          else
            echo "âœ… S3 bucket '$BUCKET_NAME' already exists"
          fi

          # Ensure required secrets exist in AWS Secrets Manager
          echo "ğŸ” Checking required secrets..."

          # Create database password secret if it doesn't exist
          if ! aws secretsmanager describe-secret --secret-id hibiji-database-password 2>/dev/null; then
            echo "Creating database password secret..."
            DB_PASSWORD=$(openssl rand -base64 32)
            aws secretsmanager create-secret \
              --name hibiji-database-password \
              --description "Database password for Hibiji platform" \
              --secret-string "$DB_PASSWORD" \
              --tags '[
                {Key=Project,Value=hibiji},
                {Key=Environment,Value=${{ needs.detect-environment.outputs.main_env }}},
                {Key=ManagedBy,Value=github-actions}
              ]'
            echo "âœ… Database password secret created"
          else
            echo "âœ… Database password secret already exists"
          fi

          # Create application secret key if it doesn't exist
          if ! aws secretsmanager describe-secret --secret-id hibiji-secret-key 2>/dev/null; then
            echo "Creating application secret key..."
            SECRET_KEY=$(openssl rand -base64 64)
            aws secretsmanager create-secret \
              --name hibiji-secret-key \
              --description "Application secret key for Hibiji platform" \
              --secret-string "$SECRET_KEY" \
              --tags '[
                {Key=Project,Value=hibiji},
                {Key=Environment,Value=${{ needs.detect-environment.outputs.main_env }}},
                {Key=ManagedBy,Value=github-actions}
              ]'
            echo "âœ… Application secret key created"
          else
            echo "âœ… Application secret key already exists"
          fi

          echo "âœ… All Terraform prerequisites ready"

      - name: Cache Terraform
        uses: actions/cache@v4
        with:
          path: |
            .terraform
            .terraform.lock.hcl
          key: ${{ runner.os }}-terraform-${{ hashFiles('terraform/**/*.tf') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Terraform Plan with retry
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        env:
          TF_VAR_sub_environment: ${{ needs.detect-environment.outputs.environment }}
          TF_VAR_environment: ${{ needs.detect-environment.outputs.main_env }}
          TF_VAR_ecr_repository_url: ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend
          TF_VAR_frontend_ecr_repository_url: ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend
          TF_VAR_image_tag: ${{ github.sha }}
          TF_VAR_frontend_image_tag: ${{ github.sha }}
        run: |
          # Retry terraform operations up to 3 times
          for i in {1..3}; do
            terraform init && break
            echo "Terraform init attempt $i failed, retrying..."
            sleep 10
          done

          for i in {1..3}; do
            terraform plan \
              -var="sub_environment=${{ needs.detect-environment.outputs.environment }}" \
              -var="environment=${{ needs.detect-environment.outputs.main_env }}" \
              -out=tfplan && break
            echo "Terraform plan attempt $i failed, retrying..."
            sleep 10
          done

      - name: Upload Terraform plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.detect-environment.outputs.environment }}
          path: terraform/environments/${{ needs.detect-environment.outputs.main_env }}/tfplan
          retention-days: 30

  # ===========================================
  # QUALITY GATE (Validates all CI results)
  # ===========================================

  quality-gate:
    name: ğŸš¦ Quality Gate
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs:
      [
        security-scan,
        backend-tests,
        frontend-tests,
        dependency-scan,
        build-and-package,
      ]
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Quality Gate Assessment
        run: |
          echo "ğŸ¯ Quality Gate Assessment"
          echo "=========================="
          echo "Security Scan: ${{ needs.security-scan.result }}"
          echo "Backend Tests: ${{ needs.backend-tests.result }}"
          echo "Frontend Tests: ${{ needs.frontend-tests.result }}"
          echo "Dependency Scan: ${{ needs.dependency-scan.result }}"
          echo "Build & Package: ${{ needs.build-and-package.result }}"

          # Check if any critical jobs failed
          if [[ "${{ needs.security-scan.result }}" == "failure" ]]; then
            echo "âŒ Security scan failed - blocking deployment"
            exit 1
          fi

          if [[ "${{ needs.backend-tests.result }}" == "failure" ]]; then
            echo "âŒ Backend tests failed - blocking deployment"
            exit 1
          fi

          if [[ "${{ needs.frontend-tests.result }}" == "failure" ]]; then
            echo "âŒ Frontend tests failed - blocking deployment"
            exit 1
          fi

          if [[ "${{ needs.build-and-package.result }}" == "failure" ]]; then
            echo "âŒ Build and package failed - blocking deployment"
            exit 1
          fi

          echo "âœ… All quality gates passed!"

  # ===========================================
  # DEPLOY PHASE (Conditional deployment)
  # ===========================================

  pre-deploy-validation:
    name: ğŸ” Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [detect-environment, build-and-package, terraform-plan, quality-gate]
    if: |
      always() && 
      needs.detect-environment.outputs.should_deploy == 'true' && 
      (needs.quality-gate.result == 'success' || github.event.inputs.force_deploy == 'true' || github.event.inputs.skip_tests == 'true')
    steps:
      - name: Pre-deployment checks
        run: |
          echo "ğŸ” Pre-deployment Validation"
          echo "============================"
          echo "Environment: ${{ needs.detect-environment.outputs.environment }}"
          echo "Should Deploy: ${{ needs.detect-environment.outputs.should_deploy }}"
          echo "Force Deploy: ${{ github.event.inputs.force_deploy }}"
          echo "Skip Tests: ${{ github.event.inputs.skip_tests }}"
          echo "Quality Gate: ${{ needs.quality-gate.result }}"

          if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "âš ï¸  Force deployment enabled - bypassing quality gate"
          elif [[ "${{ github.event.inputs.skip_tests }}" == "true" ]]; then
            echo "âš ï¸  Tests skipped - emergency deployment mode"
          else
            echo "âœ… Normal deployment - all checks passed"
          fi

  deploy:
    name: ğŸš€ Deploy to ${{ needs.detect-environment.outputs.environment }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: [detect-environment, pre-deploy-validation]
    if: |
      always() && 
      needs.detect-environment.outputs.should_deploy == 'true' && 
      needs.pre-deploy-validation.result == 'success'
    environment: ${{ needs.detect-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Download Terraform plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ needs.detect-environment.outputs.environment }}
          path: terraform/environments/${{ needs.detect-environment.outputs.main_env }}/

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ needs.detect-environment.outputs.environment }}
          path: dist/

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repositories exist
        run: |
          echo "ğŸ—ï¸ Ensuring ECR repositories exist..."

          # Create backend repository if it doesn't exist
          aws ecr describe-repositories --repository-names hibiji-backend --region ${{ env.AWS_REGION }} 2>/dev/null || {
            echo "Creating hibiji-backend repository..."
            aws ecr create-repository \
              --repository-name hibiji-backend \
              --region ${{ env.AWS_REGION }} \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256 \
              --tags Key=Project,Value=hibiji Key=Environment,Value=${{ needs.detect-environment.outputs.main_env }} Key=ManagedBy,Value=github-actions
            echo "âœ… hibiji-backend repository created"
          }

          # Create frontend repository if it doesn't exist
          aws ecr describe-repositories --repository-names hibiji-frontend --region ${{ env.AWS_REGION }} 2>/dev/null || {
            echo "Creating hibiji-frontend repository..."
            aws ecr create-repository \
              --repository-name hibiji-frontend \
              --region ${{ env.AWS_REGION }} \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256 \
              --tags Key=Project,Value=hibiji Key=Environment,Value=${{ needs.detect-environment.outputs.main_env }} Key=ManagedBy,Value=github-actions
            echo "âœ… hibiji-frontend repository created"
          }

          echo "âœ… ECR repositories ready"

      - name: Build and push Docker images
        run: |
          echo "ğŸ³ Building and pushing Docker images..."

          # Build and push backend
          docker build -t ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:${{ github.sha }} .
          docker tag ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:${{ github.sha }} \
                     ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:latest
          docker push ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:${{ github.sha }}
          docker push ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:latest

          # Build and push frontend
          docker build -t ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:${{ github.sha }} ./frontend
          docker tag ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:${{ github.sha }} \
                     ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:latest
          docker push ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:${{ github.sha }}
          docker push ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:latest

      - name: Deploy infrastructure with rollback
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        env:
          TF_VAR_sub_environment: ${{ needs.detect-environment.outputs.environment }}
          TF_VAR_environment: ${{ needs.detect-environment.outputs.main_env }}
          TF_VAR_ecr_repository_url: ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend
          TF_VAR_frontend_ecr_repository_url: ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend
          TF_VAR_image_tag: ${{ github.sha }}
          TF_VAR_frontend_image_tag: ${{ github.sha }}
        run: |
          echo "ğŸ—ï¸ Deploying infrastructure..."
          terraform init

          # Apply with automatic retry and rollback capability
          if ! terraform apply -auto-approve tfplan; then
            echo "âŒ Terraform apply failed - checking for rollback options"
            echo "Manual intervention may be required"
            exit 1
          fi

          echo "âœ… Infrastructure deployment completed"

      - name: Run health checks with retry
        run: |
          echo "ğŸ” Running post-deployment health checks..."

          # Get ALB DNS name from Terraform output (if available)
          ALB_DNS_NAME="${{ needs.detect-environment.outputs.environment }}.hibiji.com"

          # Wait for ALB to be ready and perform health checks
          for i in {1..12}; do
            echo "Health check attempt $i/12..."
            
            if curl -f -s --max-time 10 "https://$ALB_DNS_NAME/health" > /dev/null 2>&1; then
              echo "âœ… Health check passed"
              break
            elif curl -f -s --max-time 10 "http://$ALB_DNS_NAME/health" > /dev/null 2>&1; then
              echo "âœ… Health check passed (HTTP)"
              break
            else
              echo "â³ Health check failed, retrying in 30 seconds..."
              if [ $i -eq 12 ]; then
                echo "âŒ Health checks failed after 12 attempts"
                echo "ğŸ” Deployment may need manual verification"
                # Don't fail the deployment for health check failures
              fi
              sleep 30
            fi
          done

  # ===========================================
  # POST-DEPLOYMENT (Summary and notifications)
  # ===========================================

  deployment-summary:
    name: ğŸ“Š Deployment Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [detect-environment, deploy]
    if: always() && needs.detect-environment.outputs.should_deploy == 'true'
    steps:
      - name: Generate deployment summary
        run: |
          echo "ğŸ¯ Deployment Summary"
          echo "===================="
          echo "Environment: ${{ needs.detect-environment.outputs.environment }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
          echo "Deployment Status: ${{ needs.deploy.result }}"
          echo "Timestamp: $(date -u)"

          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo ""
            echo "âœ… Deployment completed successfully!"
            echo "ğŸŒ Application should be available at:"
            echo "   https://${{ needs.detect-environment.outputs.environment }}.hibiji.com"
            echo ""
            echo "ğŸ“Š Next steps:"
            echo "   â€¢ Verify application functionality"
            echo "   â€¢ Monitor performance metrics"
            echo "   â€¢ Check logs for any issues"
          else
            echo ""
            echo "âŒ Deployment failed!"
            echo "ğŸ” Please check the deployment logs for details"
            echo "ğŸ› ï¸  Manual intervention may be required"
          fi
