name: Digital Persona Platform - Unified CI/CD (Optimized v2)

on:
  push:
    branches:
      - main
      - "dev[0-9][0-9]"
      - "qa[0-9][0-9]"
      - "staging[0-9][0-9]"
      - "hotfix[0-9][0-9]"
  pull_request:
    branches:
      - main
      - "dev[0-9][0-9]"
      - "qa[0-9][0-9]"
      - "staging[0-9][0-9]"
      - "hotfix[0-9][0-9]"
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force deployment even if tests fail"
        required: false
        default: false
        type: boolean
      skip_tests:
        description: "Skip test execution for emergency deployments"
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  security-events: write
  actions: read
  contents: read

env:
  AWS_REGION: us-west-1
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "18"
  DOMAIN: hibiji.com
  TERRAFORM_VERSION: "1.5.0"

# Prevent multiple runs from conflicting
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ===========================================
  # ENVIRONMENT DETECTION
  # ===========================================
  detect-environment:
    name: ğŸ” Environment Detection
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      main_env: ${{ steps.env.outputs.main_env }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
      is_numbered_env: ${{ steps.env.outputs.is_numbered_env }}
      ecr_registry: ${{ steps.env.outputs.ecr_registry }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine Environment and AWS Registry
        id: env
        run: |
          # Determine environment based on branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prod"
            MAIN_ENV="prod"
            SHOULD_DEPLOY="false"  # Main branch requires manual deployment
            IS_NUMBERED_ENV="false"
          elif [[ "${{ github.ref_name }}" =~ ^dev[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="dev"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          elif [[ "${{ github.ref_name }}" =~ ^qa[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="qa"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          elif [[ "${{ github.ref_name }}" =~ ^staging[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="staging"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          elif [[ "${{ github.ref_name }}" =~ ^hotfix[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="hotfix"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          else
            echo "âŒ Invalid branch name: ${{ github.ref_name }}"
            echo "âŒ Only these formats are allowed: dev##, qa##, staging##, hotfix##, main"
            exit 1
          fi

          # Get AWS Account ID dynamically
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

          # Set ECR registry for later use
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "main_env=$MAIN_ENV" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "is_numbered_env=$IS_NUMBERED_ENV" >> $GITHUB_OUTPUT
          echo "ecr_registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT

          echo "ğŸ¯ Environment: $ENVIRONMENT"
          echo "ğŸ—ï¸  Main Environment: $MAIN_ENV"
          echo "ğŸš€ Should Deploy: $SHOULD_DEPLOY"
          echo "ğŸ”— ECR Registry: $ECR_REGISTRY"

  # ===========================================
  # PARALLEL CI PHASE (All run simultaneously)
  # ===========================================

  security-scan:
    name: ğŸ›¡ï¸ Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache security scan results
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/trivy
            ~/.cache/semgrep
          key: ${{ runner.os }}-security-${{ hashFiles('**/requirements.txt', '**/package*.json') }}
          restore-keys: |
            ${{ runner.os }}-security-

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: Run TruffleHog secret scanner
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --exclude-paths=.trufflehogignore
        continue-on-error: true

  backend-tests:
    name: ğŸ Backend Tests (${{ matrix.python-version }})
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event.inputs.skip_tests != 'true'
    strategy:
      matrix:
        python-version: ["3.11"]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install --upgrade setuptools wheel
          pip install -r requirements.txt --use-pep517

      - name: Run tests
        run: |
          python -m pytest tests/ -v --cov=app --cov-report=xml

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        if: always()
        with:
          file: ./coverage.xml
          flags: backend
          name: backend-coverage
          fail_ci_if_error: false

  frontend-tests:
    name: âš›ï¸ Frontend Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event.inputs.skip_tests != 'true'
    defaults:
      run:
        working-directory: ./frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run frontend tests
        run: npm test -- --coverage --watchAll=false

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        if: always()
        with:
          directory: ./frontend/coverage
          flags: frontend
          name: frontend-coverage
          fail_ci_if_error: false

  dependency-scan:
    name: ğŸ“¦ Dependency Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run dependency vulnerability scan
        uses: pypa/gh-action-pip-audit@v1.0.8
        with:
          inputs: requirements.txt

  terraform-plan:
    name: ğŸ—ï¸ Terraform Plan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [detect-environment]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    outputs:
      plan_id: ${{ steps.plan.outputs.plan_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Cache Terraform
        uses: actions/cache@v4
        with:
          path: |
            .terraform
            .terraform.lock.hcl
          key: ${{ runner.os }}-terraform-${{ hashFiles('**/terraform/**/*.tf') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Terraform Init
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        run: |
          terraform init \
            -backend-config="bucket=hibiji-terraform-state" \
            -backend-config="key=${{ needs.detect-environment.outputs.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Plan
        id: plan
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        run: |
          terraform plan \
            -var="environment=${{ needs.detect-environment.outputs.environment }}" \
            -var="domain_name=${{ env.DOMAIN }}" \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -out=tfplan

          # Generate readable plan
          terraform show -no-color tfplan > plan.txt
          echo "plan_id=tfplan" >> $GITHUB_OUTPUT

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.detect-environment.outputs.environment }}
          path: |
            terraform/environments/${{ needs.detect-environment.outputs.main_env }}/tfplan
            terraform/environments/${{ needs.detect-environment.outputs.main_env }}/plan.txt

  # ===========================================
  # BUILD & PACKAGE PHASE
  # ===========================================
  build-and-package:
    name: ğŸ—ï¸ Build & Package
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs:
      [
        detect-environment,
        security-scan,
        backend-tests,
        frontend-tests,
        dependency-scan,
        terraform-plan,
      ]
    if: |
      always() && 
      needs.detect-environment.result == 'success' &&
      (needs.security-scan.result == 'success' || github.event.inputs.skip_tests == 'true') &&
      (needs.backend-tests.result == 'success' || github.event.inputs.skip_tests == 'true') &&
      (needs.frontend-tests.result == 'success' || github.event.inputs.skip_tests == 'true') &&
      (needs.dependency-scan.result == 'success' || github.event.inputs.skip_tests == 'true') &&
      (needs.terraform-plan.result == 'success' || github.event.inputs.force_deploy == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Clean up disk space
        run: |
          # Remove unnecessary files to free up space
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf "/usr/local/share/boost"
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          df -h

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repositories if they don't exist
        run: |
          # Create backend repository
          aws ecr describe-repositories --repository-names hibiji-backend --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository \
            --repository-name hibiji-backend \
            --region ${{ env.AWS_REGION }} \
            --tags Key=Environment,Value=${{ needs.detect-environment.outputs.environment }} \
                   Key=Project,Value=hibiji \
                   Key=ManagedBy,Value=github-actions

          # Create frontend repository  
          aws ecr describe-repositories --repository-names hibiji-frontend --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository \
            --repository-name hibiji-frontend \
            --region ${{ env.AWS_REGION }} \
            --tags Key=Environment,Value=${{ needs.detect-environment.outputs.environment }} \
                   Key=Project,Value=hibiji \
                   Key=ManagedBy,Value=github-actions

      - name: Build and push backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:${{ github.sha }}
            ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:latest
          # Use registry cache to avoid disk space issues
          cache-from: type=registry,ref=${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:cache
          cache-to: type=registry,ref=${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:cache,mode=max

      - name: Build and push frontend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          platforms: linux/amd64
          push: true
          tags: |
            ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:${{ github.sha }}
            ${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:latest
          # Use registry cache to avoid disk space issues
          cache-from: type=registry,ref=${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:cache
          cache-to: type=registry,ref=${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:cache,mode=max

      - name: Create build artifacts
        run: |
          mkdir -p build-artifacts
          echo "${{ github.sha }}" > build-artifacts/commit-sha.txt
          echo "${{ needs.detect-environment.outputs.environment }}" > build-artifacts/environment.txt
          echo "${{ needs.detect-environment.outputs.ecr_registry }}" > build-artifacts/ecr-registry.txt

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ needs.detect-environment.outputs.environment }}
          path: build-artifacts/

  # ===========================================
  # DEPLOYMENT PHASE
  # ===========================================
  deploy:
    name: ğŸš€ Deploy to ${{ needs.detect-environment.outputs.environment }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [detect-environment, terraform-plan, build-and-package]
    if: |
      always() && 
      needs.detect-environment.outputs.should_deploy == 'true' &&
      needs.detect-environment.result == 'success' &&
      needs.terraform-plan.result == 'success' &&
      (needs.build-and-package.result == 'success' || github.event.inputs.force_deploy == 'true')
    environment:
      name: ${{ needs.detect-environment.outputs.environment }}
      url: https://${{ needs.detect-environment.outputs.environment }}.${{ env.DOMAIN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ needs.detect-environment.outputs.environment }}
          path: terraform/environments/${{ needs.detect-environment.outputs.main_env }}/

      - name: Create AWS Secrets if they don't exist
        run: |
          # Create database password secret if it doesn't exist
          aws secretsmanager describe-secret --secret-id "hibiji/${{ needs.detect-environment.outputs.environment }}/database/password" --region ${{ env.AWS_REGION }} || \
          aws secretsmanager create-secret \
            --name "hibiji/${{ needs.detect-environment.outputs.environment }}/database/password" \
            --description "Database password for ${{ needs.detect-environment.outputs.environment }}" \
            --secret-string "$(openssl rand -base64 32)" \
            --region ${{ env.AWS_REGION }} \
            --tags '[{"Key":"Environment","Value":"${{ needs.detect-environment.outputs.environment }}"},{"Key":"Project","Value":"hibiji"},{"Key":"ManagedBy","Value":"github-actions"}]'

          # Create application secret key if it doesn't exist
          aws secretsmanager describe-secret --secret-id "hibiji/${{ needs.detect-environment.outputs.environment }}/app/secret-key" --region ${{ env.AWS_REGION }} || \
          aws secretsmanager create-secret \
            --name "hibiji/${{ needs.detect-environment.outputs.environment }}/app/secret-key" \
            --description "Application secret key for ${{ needs.detect-environment.outputs.environment }}" \
            --secret-string "$(openssl rand -base64 64)" \
            --region ${{ env.AWS_REGION }} \
            --tags '[{"Key":"Environment","Value":"${{ needs.detect-environment.outputs.environment }}"},{"Key":"Project","Value":"hibiji"},{"Key":"ManagedBy","Value":"github-actions"}]'

      - name: Create S3 Terraform Backend Bucket
        run: |
          # Create S3 bucket for Terraform state if it doesn't exist
          aws s3api head-bucket --bucket "hibiji-terraform-state" --region ${{ env.AWS_REGION }} || \
          aws s3api create-bucket \
            --bucket "hibiji-terraform-state" \
            --region ${{ env.AWS_REGION }} \
            --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}

          # Enable versioning
          aws s3api put-bucket-versioning \
            --bucket "hibiji-terraform-state" \
            --versioning-configuration Status=Enabled

          # Enable encryption
          aws s3api put-bucket-encryption \
            --bucket "hibiji-terraform-state" \
            --server-side-encryption-configuration '{
              "Rules": [
                {
                  "ApplyServerSideEncryptionByDefault": {
                    "SSEAlgorithm": "AES256"
                  }
                }
              ]
            }'

          # Apply tags
          aws s3api put-bucket-tagging \
            --bucket "hibiji-terraform-state" \
            --tagging '{"TagSet":[{"Key":"Environment","Value":"shared"},{"Key":"Project","Value":"hibiji"},{"Key":"ManagedBy","Value":"github-actions"}]}'

      - name: Terraform Init
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        run: |
          terraform init \
            -backend-config="bucket=hibiji-terraform-state" \
            -backend-config="key=${{ needs.detect-environment.outputs.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Apply
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        run: |
          terraform apply -auto-approve tfplan

      - name: Get infrastructure outputs
        id: terraform-outputs
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        run: |
          echo "alb_dns=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT
          echo "cluster_name=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ needs.detect-environment.outputs.environment }}
          path: build-artifacts/

      - name: Deploy application to ECS
        run: |
          # Get the latest task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "hibiji-${{ needs.detect-environment.outputs.environment }}-backend" \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition' \
            --output json | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')

          # Update image URIs
          UPDATED_TASK_DEF=$(echo $TASK_DEF | jq \
            --arg BACKEND_IMAGE "${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-backend:${{ github.sha }}" \
            --arg FRONTEND_IMAGE "${{ needs.detect-environment.outputs.ecr_registry }}/hibiji-frontend:${{ github.sha }}" \
            '.containerDefinitions |= map(
              if .name == "backend" then .image = $BACKEND_IMAGE
              elif .name == "frontend" then .image = $FRONTEND_IMAGE
              else . end
            )')

          # Register new task definition
          echo $UPDATED_TASK_DEF > updated-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://updated-task-def.json \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          # Update service
          aws ecs update-service \
            --cluster "${{ steps.terraform-outputs.outputs.cluster_name }}" \
            --service "hibiji-${{ needs.detect-environment.outputs.environment }}-service" \
            --task-definition "$NEW_TASK_DEF_ARN" \
            --region ${{ env.AWS_REGION }}

          # Wait for deployment to complete
          aws ecs wait services-stable \
            --cluster "${{ steps.terraform-outputs.outputs.cluster_name }}" \
            --services "hibiji-${{ needs.detect-environment.outputs.environment }}-service" \
            --region ${{ env.AWS_REGION }}

      - name: Run post-deployment health check
        run: |
          # Wait a bit for the service to be ready
          sleep 30

          # Health check
          HEALTH_URL="https://${{ needs.detect-environment.outputs.environment }}.${{ env.DOMAIN }}/health"

          for i in {1..10}; do
            if curl -f -s "$HEALTH_URL" > /dev/null; then
              echo "âœ… Health check passed"
              break
            else
              echo "â³ Health check attempt $i/10 failed, retrying in 30s..."
              sleep 30
            fi
          done

      - name: Update deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "ğŸ‰ Deployment to ${{ needs.detect-environment.outputs.environment }} completed successfully!"
            echo "ğŸŒ Application URL: https://${{ needs.detect-environment.outputs.environment }}.${{ env.DOMAIN }}"
          else
            echo "âŒ Deployment to ${{ needs.detect-environment.outputs.environment }} failed"
          fi
