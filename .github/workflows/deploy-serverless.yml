name: Deploy Serverless Architecture

on:
  push:
    branches:
      - dev01
      - dev02
      - main
      - staging
      - prod
  pull_request:
    branches:
      - dev01
      - dev02
      - main
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force deployment even if tests fail"
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  security-events: write
  actions: read
  contents: read

env:
  AWS_REGION: us-west-1
  NODE_VERSION: 20

jobs:
  # =================================
  # Build and Test
  # =================================
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint --if-present

      - name: Run type checking
        run: npm run type-check --if-present

      - name: Run tests
        run: npm run test --if-present

  # =================================
  # Build Frontend for Static Export
  # =================================
  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    needs: build-and-test

    outputs:
      frontend-hash: ${{ steps.frontend-hash.outputs.hash }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build shared packages
        run: |
          npm run build --workspace=@digital-persona/shared
          npm run build --workspace=@digital-persona/database

      - name: Build frontend for static export
        env:
          NODE_ENV: production
          NEXT_BUILD_EXPORT: true
          # Set API URL based on branch
          NEXT_PUBLIC_API_URL: >-
            ${{ 
              github.ref == 'refs/heads/main' && secrets.API_URL_MAIN ||
              github.ref == 'refs/heads/staging' && secrets.API_URL_STAGING ||
              github.ref == 'refs/heads/prod' && secrets.API_URL_PROD ||
              secrets.API_URL_DEV 
            }}
        run: |
          cd apps/web
          echo "üèóÔ∏è Building frontend for static export..."
          npm run build
          echo "‚úÖ Frontend build completed"

      - name: Validate build output
        run: |
          cd apps/web
          if [ ! -d "out" ]; then
            echo "‚ùå Error: 'out' directory not found after build"
            echo "üìÅ Available directories:"
            ls -la
            exit 1
          fi

          if [ -z "$(ls -A out)" ]; then
            echo "‚ùå Error: 'out' directory is empty"
            exit 1
          fi

          echo "‚úÖ Build output validation passed"
          echo "üìÅ Files in out directory:"
          ls -la out/

      - name: Generate frontend hash
        id: frontend-hash
        run: |
          cd apps/web
          if [ ! -d "out" ] || [ -z "$(ls -A out)" ]; then
            echo "‚ùå Frontend build output is empty! Failing the job."
            exit 1
          fi

          hash=$(find out -type f -exec sha256sum {} \; | sha256sum | cut -d' ' -f1)
          echo "hash=${hash:0:8}" >> $GITHUB_OUTPUT
          echo "‚úÖ Generated frontend hash: ${hash:0:8}"

      - name: Upload frontend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ steps.frontend-hash.outputs.hash }}
          path: apps/web/out/
          retention-days: 7

  # =================================
  # Build Backend Lambda Package
  # =================================
  build-backend:
    name: Build Backend Lambda
    runs-on: ubuntu-latest
    needs: build-and-test

    outputs:
      backend-hash: ${{ steps.backend-hash.outputs.hash }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build shared packages
        run: |
          npm run build --workspace=@digital-persona/shared
          npm run build --workspace=@digital-persona/database

      - name: Build backend for Lambda
        run: |
          cd apps/server
          npm run build

      - name: Create Lambda deployment package
        run: |
          echo "üèóÔ∏è Creating comprehensive Lambda deployment package..."

          # Install production dependencies at root level (for workspaces)
          npm ci --omit=dev --ignore-scripts

          cd apps/server
          # Create deployment directory
          mkdir -p deployment

          # Copy built files
          echo "üì¶ Copying built JavaScript files..."
          cp -r dist/* deployment/

          # Copy package.json for Lambda runtime
          cp package.json deployment/

          echo "üì¶ Creating comprehensive node_modules for Lambda..."
          mkdir -p deployment/node_modules

          # Copy ALL production dependencies for server
          echo "üì¶ Copying all server dependencies..."

          # Get all dependencies from package.json
          SERVER_DEPS=$(node -e "
            const pkg = require('./package.json');
            const deps = Object.keys(pkg.dependencies || {});
            console.log(deps.join(' '));
          ")

          echo "üìã Server dependencies to copy: $SERVER_DEPS"

          # Build and copy workspace packages properly
          echo "üì¶ Building and copying workspace packages..."

          # Ensure workspace packages are built
          cd ../..
          echo "üîß Building workspace packages..."
          npm run build --workspace=@digital-persona/shared --if-present
          npm run build --workspace=@digital-persona/database --if-present

          cd apps/server

          # Create @digital-persona directory in deployment
          mkdir -p deployment/node_modules/@digital-persona

          # Copy @digital-persona/shared
          if [ -d "../../packages/shared" ]; then
            echo "üì¶ Copying @digital-persona/shared..."
            mkdir -p deployment/node_modules/@digital-persona/shared
            cp -r ../../packages/shared/dist deployment/node_modules/@digital-persona/shared/
            cp ../../packages/shared/package.json deployment/node_modules/@digital-persona/shared/
            echo "‚úÖ @digital-persona/shared copied with dist folder"
          else
            echo "‚ùå @digital-persona/shared source not found"
          fi

          # Copy @digital-persona/database  
          if [ -d "../../packages/database" ]; then
            echo "üì¶ Copying @digital-persona/database..."
            mkdir -p deployment/node_modules/@digital-persona/database
            cp -r ../../packages/database/dist deployment/node_modules/@digital-persona/database/
            cp ../../packages/database/package.json deployment/node_modules/@digital-persona/database/
            echo "‚úÖ @digital-persona/database copied with dist folder"
          else
            echo "‚ùå @digital-persona/database source not found"
          fi

          # Verify workspace packages were copied correctly
          echo "üîç Verifying workspace packages..."
          if [ -f "deployment/node_modules/@digital-persona/database/package.json" ]; then
            echo "‚úÖ @digital-persona/database package.json found"
          else
            echo "‚ùå @digital-persona/database package.json missing"
          fi

          if [ -d "deployment/node_modules/@digital-persona/database/dist" ]; then
            echo "‚úÖ @digital-persona/database dist folder found"
            ls -la deployment/node_modules/@digital-persona/database/dist/
          else
            echo "‚ùå @digital-persona/database dist folder missing"
          fi

          # Copy ALL server dependencies and their transitive dependencies
          for pkg in $SERVER_DEPS; do
            if [ -d "../../node_modules/$pkg" ]; then
              echo "üì¶ Copying $pkg..."
              cp -r "../../node_modules/$pkg" deployment/node_modules/
            else
              echo "‚ö†Ô∏è Warning: $pkg not found in node_modules"
            fi
          done

          # Copy critical transitive dependencies that might be missing
          echo "üì¶ Copying critical transitive dependencies..."
          CRITICAL_DEPS="pg-pool pg-connection-string pg-types pg-int8 pg-protocol postgres-array postgres-bytea postgres-date postgres-interval @types/pg drizzle-kit"

          for pkg in $CRITICAL_DEPS; do
            if [ -d "../../node_modules/$pkg" ]; then
              echo "üì¶ Copying critical dependency $pkg..."
              cp -r "../../node_modules/$pkg" deployment/node_modules/
            fi
          done

          # Ensure essential runtime dependencies exist
          echo "üîç Verifying critical dependencies..."
          REQUIRED_PACKAGES="pg express cors serverless-http drizzle-orm @trpc/server zod superjson jsonwebtoken bcryptjs uuid better-auth dotenv"

          for pkg in $REQUIRED_PACKAGES; do
            if [ ! -d "deployment/node_modules/$pkg" ]; then
              echo "‚ùå CRITICAL: Missing required package $pkg"
              # Try to find it with different path patterns
              find ../../node_modules -name "*$pkg*" -type d | head -5
            else
              echo "‚úÖ Found required package $pkg"
            fi
          done

          # Create zip file
          echo "üì¶ Creating Lambda deployment zip..."
          cd deployment

          # Show package size info
          echo "üìä Package contents summary:"
          du -sh . 2>/dev/null || echo "Size calculation failed"
          echo "üìÅ Files in package:"
          ls -la
          echo "üì¶ Node modules included:"
          ls node_modules/ | head -20

          zip -r ../lambda-deployment.zip . -q
          cd ..

          # Show final package info
          PACKAGE_SIZE=$(du -sh lambda-deployment.zip | cut -f1)
          echo "‚úÖ Lambda deployment package created: $PACKAGE_SIZE"

          # Clean up
          rm -rf deployment

      - name: Generate backend hash
        id: backend-hash
        run: |
          cd apps/server
          hash=$(sha256sum lambda-deployment.zip | cut -d' ' -f1)
          echo "hash=${hash:0:8}" >> $GITHUB_OUTPUT

      - name: Upload backend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build-${{ steps.backend-hash.outputs.hash }}
          path: apps/server/lambda-deployment.zip
          retention-days: 7

  # =================================
  # Deploy Infrastructure
  # =================================
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [build-frontend, build-backend]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    environment: >-
      ${{ 
        github.ref == 'refs/heads/main' && 'main' ||
        github.ref == 'refs/heads/staging' && 'staging' ||
        github.ref == 'refs/heads/prod' && 'prod' ||
        'dev'
      }}

    outputs:
      website-bucket: ${{ steps.terraform-output.outputs.website-bucket }}
      api-url: ${{ steps.terraform-output.outputs.api-url }}
      lambda-function: ${{ steps.terraform-output.outputs.lambda-function }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-ServerlessDeploy

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Determine environment and sub-environment
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=main" >> $GITHUB_OUTPUT
            echo "sub_environment=main" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "sub_environment=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/prod" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "sub_environment=prod" >> $GITHUB_OUTPUT
          else
            # Extract sub-environment from branch name (e.g., dev01, dev02)
            branch_name="${{ github.ref_name }}"
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "sub_environment=${branch_name}" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Init
        run: |
          cd terraform/environments/${{ steps.env.outputs.environment }}
          terraform init

      - name: Terraform Plan
        run: |
          cd terraform/environments/${{ steps.env.outputs.environment }}
          terraform plan \
            -var="sub_environment=${{ steps.env.outputs.sub_environment }}" \
            -input=false \
            -out=tfplan

      - name: Terraform Apply
        run: |
          cd terraform/environments/${{ steps.env.outputs.environment }}
          terraform apply -input=false tfplan

      - name: Get Terraform outputs
        id: terraform-output
        run: |
          cd terraform/environments/${{ steps.env.outputs.environment }}
          echo "website-bucket=$(terraform output -raw website_bucket_name)" >> $GITHUB_OUTPUT
          echo "api-url=$(terraform output -raw api_url)" >> $GITHUB_OUTPUT
          echo "lambda-function=$(terraform output -raw lambda_function_name)" >> $GITHUB_OUTPUT

  # =================================
  # Deploy Frontend to S3
  # =================================
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [build-frontend, deploy-infrastructure]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-FrontendDeploy

      - name: Download frontend build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ needs.build-frontend.outputs.frontend-hash }}
          path: frontend-build/

      - name: Deploy to S3
        run: |
          aws s3 sync frontend-build/ s3://${{ needs.deploy-infrastructure.outputs.website-bucket }}/ \
            --delete \
            --cache-control "public, max-age=31536000" \
            --exclude "*.html" \
            --exclude "*.json"

          # Deploy HTML files with shorter cache
          aws s3 sync frontend-build/ s3://${{ needs.deploy-infrastructure.outputs.website-bucket }}/ \
            --delete \
            --cache-control "public, max-age=3600" \
            --include "*.html" \
            --include "*.json"

      - name: Invalidate CloudFront cache
        run: |
          # Get CloudFront distribution ID
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='${{ needs.deploy-infrastructure.outputs.website-bucket }}'].Id" \
            --output text)

          if [ ! -z "$DISTRIBUTION_ID" ]; then
            aws cloudfront create-invalidation \
              --distribution-id $DISTRIBUTION_ID \
              --paths "/*"
          fi

  # =================================
  # Deploy Backend Lambda
  # =================================
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [build-backend, deploy-infrastructure]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-BackendDeploy

      - name: Download backend build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build-${{ needs.build-backend.outputs.backend-hash }}
          path: backend-build/

      - name: Update Lambda function
        run: |
          aws lambda update-function-code \
            --function-name ${{ needs.deploy-infrastructure.outputs.lambda-function }} \
            --zip-file fileb://backend-build/lambda-deployment.zip

      - name: Wait for Lambda update to complete
        run: |
          aws lambda wait function-updated \
            --function-name ${{ needs.deploy-infrastructure.outputs.lambda-function }}

  # =================================
  # Health Check and Smoke Tests
  # =================================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-backend, deploy-infrastructure]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-HealthCheck

      - name: Test API health endpoint with detailed error capture
        run: |
          API_URL="${{ needs.deploy-infrastructure.outputs.api-url }}"
          echo "üîç Testing API health endpoint with detailed error capture"
          echo "================================================"
          echo "API URL: $API_URL/health"
          echo ""

          # Function to perform detailed health check
          perform_health_check() {
            local attempt=$1
            echo "üîç Health Check Attempt $attempt/10"
            echo "============================="
            
            # Create temporary files for response capture
            local response_body=$(mktemp)
            local response_headers=$(mktemp)
            
            # Perform request with full details capture
            local http_status=$(curl -s -w "%{http_code}" \
              --connect-timeout 10 \
              --max-time 30 \
              --dump-header "$response_headers" \
              --output "$response_body" \
              "$API_URL/health" 2>&1)
            
            local curl_exit_code=$?
            
            echo "üìä Request Details:"
            echo "  URL: $API_URL/health"
            echo "  HTTP Status: $http_status"
            echo "  Curl Exit Code: $curl_exit_code"
            echo "  Timestamp: $(date -u)"
            echo ""
            
            # Display response headers
            echo "üìã Response Headers:"
            echo "==================="
            if [ -f "$response_headers" ] && [ -s "$response_headers" ]; then
              cat "$response_headers"
            else
              echo "  (No headers captured)"
            fi
            echo ""
            
            # Display response body
            echo "üìÑ Response Body:"
            echo "================="
            if [ -f "$response_body" ] && [ -s "$response_body" ]; then
              echo "  Content Length: $(wc -c < "$response_body") bytes"
              echo "  Raw Response:"
              echo "  ============="
              cat "$response_body" | head -100  # Limit to first 100 lines
              echo ""
              
              # Try to pretty-print JSON if it's JSON
              if cat "$response_body" | jq . >/dev/null 2>&1; then
                echo "  Pretty-printed JSON:"
                echo "  ==================="
                cat "$response_body" | jq .
              fi
            else
              echo "  (No response body captured)"
            fi
            echo ""
            
            # Analyze the result
            if [ "$curl_exit_code" -eq 0 ] && [ "$http_status" = "200" ]; then
              echo "‚úÖ SUCCESS: API health check passed!"
              cleanup_temp_files "$response_body" "$response_headers"
              return 0
            elif [ "$curl_exit_code" -ne 0 ]; then
              echo "‚ùå CURL ERROR: Network/connection issue (exit code: $curl_exit_code)"
              if [ "$curl_exit_code" -eq 7 ]; then
                echo "   Failed to connect to host"
              elif [ "$curl_exit_code" -eq 28 ]; then
                echo "   Operation timeout"
              elif [ "$curl_exit_code" -eq 6 ]; then
                echo "   Couldn't resolve host"
              fi
            elif [ "$http_status" = "500" ]; then
              echo "‚ùå HTTP 500 ERROR: Internal Server Error"
              echo "üîç DEBUGGING INFORMATION:"
              echo "========================"
              
              # Check if it's a Lambda error
              if grep -q "errorType\|errorMessage" "$response_body" 2>/dev/null; then
                echo "üö® Lambda Function Error Detected:"
                cat "$response_body" | jq -r '.errorType // "Unknown"' 2>/dev/null || echo "  Could not parse error type"
                echo "Error Message:"
                cat "$response_body" | jq -r '.errorMessage // "Unknown"' 2>/dev/null || cat "$response_body"
                echo ""
                echo "Stack Trace:"
                cat "$response_body" | jq -r '.trace[]? // empty' 2>/dev/null || echo "  No stack trace available"
              fi
              
              # Check for common Lambda issues
              if grep -q "Task timed out" "$response_body" 2>/dev/null; then
                echo "‚è±Ô∏è Lambda Timeout Detected"
              elif grep -q "Runtime exited with error" "$response_body" 2>/dev/null; then
                echo "üî• Lambda Runtime Error Detected"
              elif grep -q "Cannot find module" "$response_body" 2>/dev/null; then
                echo "üì¶ Missing Node.js Module Detected"
              elif grep -q "Permission denied" "$response_body" 2>/dev/null; then
                echo "üîí Permission Error Detected"
              fi
              
            elif [ "$http_status" = "502" ]; then
              echo "‚ùå HTTP 502 ERROR: Bad Gateway (API Gateway issue)"
            elif [ "$http_status" = "503" ]; then
              echo "‚ùå HTTP 503 ERROR: Service Unavailable"
            elif [ "$http_status" = "504" ]; then
              echo "‚ùå HTTP 504 ERROR: Gateway Timeout"
            else
              echo "‚ùå HTTP $http_status ERROR: Unexpected status code"
            fi
            
            cleanup_temp_files "$response_body" "$response_headers"
            return 1
          }

          # Function to cleanup temporary files
          cleanup_temp_files() {
            [ -f "$1" ] && rm -f "$1"
            [ -f "$2" ] && rm -f "$2"
          }

          # Retry logic with detailed reporting
          HEALTH_CHECK_PASSED=false
          for i in {1..10}; do
            echo ""
            if perform_health_check $i; then
              HEALTH_CHECK_PASSED=true
              break
            else
              if [ $i -lt 10 ]; then
                echo "‚è≥ Waiting 30 seconds before next attempt..."
                sleep 30
              fi
            fi
          done

          echo ""
          echo "üéØ Final Health Check Result:"
          echo "============================="
          if [ "$HEALTH_CHECK_PASSED" = "true" ]; then
                       echo "‚úÖ API health check PASSED after $i attempts"
           else
             echo "‚ùå API health check FAILED after 10 attempts"
             echo "üí° Next steps for debugging:"
             echo "  1. Check Lambda function logs in CloudWatch"
             echo "  2. Verify Lambda function configuration"
             echo "  3. Check API Gateway configuration"
             echo "  4. Review Lambda deployment package"
             exit 1
           fi

      - name: Capture Lambda function logs for debugging
        if: failure()
        run: |
          echo "üîç Capturing Comprehensive Lambda Function Analysis"
          echo "=================================================="

          LAMBDA_FUNCTION="${{ needs.deploy-infrastructure.outputs.lambda-function }}"
          echo "Lambda Function: $LAMBDA_FUNCTION"
          echo ""

          # Get the log group name for the Lambda function
          LOG_GROUP="/aws/lambda/$LAMBDA_FUNCTION"
          echo "Log Group: $LOG_GROUP"
          echo ""

          # 1. ENHANCED LAMBDA CONFIGURATION ANALYSIS
          echo "üîß Enhanced Lambda Configuration Analysis:"
          echo "=========================================="
          aws lambda get-function-configuration --function-name "$LAMBDA_FUNCTION" --query '{
            Runtime: Runtime,
            MemorySize: MemorySize,
            Timeout: Timeout,
            Environment: Environment,
            LastModified: LastModified,
            State: State,
            StateReason: StateReason,
            LastUpdateStatus: LastUpdateStatus,
            LastUpdateStatusReason: LastUpdateStatusReason,
            CodeSize: CodeSize,
            Layers: Layers
          }' --output table
          echo ""

          # 2. CHECK FOR RECENT DEPLOYMENT ISSUES
          echo "üöÄ Recent Deployment Status:"
          echo "============================="
          aws lambda get-function --function-name "$LAMBDA_FUNCTION" --query '{
            State: Configuration.State,
            StateReason: Configuration.StateReason,
            LastUpdateStatus: Configuration.LastUpdateStatus,
            LastUpdateStatusReason: Configuration.LastUpdateStatusReason,
            PackageType: Configuration.PackageType
          }' --output table
          echo ""

          # 3. REAL-TIME LOG STREAMING DURING TEST
          echo "üîÑ Real-time Log Analysis During Health Check:"
          echo "=============================================="

          # Start log streaming in background
          echo "Starting real-time log streaming..."
          aws logs tail "$LOG_GROUP" --follow --since 1m &
          LOG_TAIL_PID=$!

          # Give logs a moment to start
          sleep 2

          # Trigger another health check to capture real-time logs
          echo "üîç Triggering health check while monitoring logs..."
          API_URL="${{ needs.deploy-infrastructure.outputs.api-url }}"

          curl -v "$API_URL/health" 2>&1 | tee health_check_response.log || true

          # Stop log streaming
          sleep 5
          kill $LOG_TAIL_PID 2>/dev/null || true
          echo ""

          # 4. DETAILED LOG ANALYSIS
          echo "üìÑ Detailed CloudWatch Log Analysis:"
          echo "===================================="

          # Check if log group exists
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[0].logGroupName' --output text | grep -q "$LOG_GROUP"; then
            echo "‚úÖ Log group found: $LOG_GROUP"
            echo ""
            
            # Get recent log streams (last 1 hour)
            echo "üìã Recent Log Streams:"
            echo "====================="
            RECENT_STREAMS=$(aws logs describe-log-streams \
              --log-group-name "$LOG_GROUP" \
              --order-by LastEventTime \
              --descending \
              --max-items 5 \
              --query 'logStreams[].{streamName:logStreamName,lastEvent:lastEventTime}' \
              --output table)
            echo "$RECENT_STREAMS"
            echo ""
            
            # Get the most recent log stream
            LATEST_STREAM=$(aws logs describe-log-streams \
              --log-group-name "$LOG_GROUP" \
              --order-by LastEventTime \
              --descending \
              --max-items 1 \
              --query 'logStreams[0].logStreamName' \
              --output text)
            
            if [ "$LATEST_STREAM" != "None" ] && [ -n "$LATEST_STREAM" ]; then
              echo "üîç Latest Log Stream: $LATEST_STREAM"
              echo ""
              
              # Get recent log events (last 10 minutes for more detailed capture)
              echo "üìÑ Recent Log Events (last 10 minutes):"
              echo "======================================="
              
              # Calculate timestamp for 10 minutes ago
              TEN_MIN_AGO=$(date -d '10 minutes ago' +%s)000  # CloudWatch expects milliseconds
              
              aws logs get-log-events \
                --log-group-name "$LOG_GROUP" \
                --log-stream-name "$LATEST_STREAM" \
                --start-time "$TEN_MIN_AGO" \
                --query 'events[].[timestamp,message]' \
                --output text | while IFS=$'\t' read -r timestamp message; do
                  # Convert timestamp to human readable
                  readable_time=$(date -d "@$((timestamp/1000))" "+%Y-%m-%d %H:%M:%S UTC")
                  echo "[$readable_time] $message"
                done
              
              echo ""
              echo "üö® Error Analysis - Filtering for Lambda Issues:"
              echo "==============================================="
              
              # Enhanced error filtering
              aws logs get-log-events \
                --log-group-name "$LOG_GROUP" \
                --log-stream-name "$LATEST_STREAM" \
                --start-time "$TEN_MIN_AGO" \
                --output text | grep -i -E "(error|exception|fail|timeout|crash|unable|cannot|denied|invalid|missing|undefined|null|task timed out|runtime|cold start|init|start)" || echo "No obvious error patterns found"
              
              echo ""
              echo "üîç Lambda Lifecycle Events:"
              echo "============================"
              
              # Look for Lambda lifecycle events
              aws logs get-log-events \
                --log-group-name "$LOG_GROUP" \
                --log-stream-name "$LATEST_STREAM" \
                --start-time "$TEN_MIN_AGO" \
                --output text | grep -i -E "(start|init|cold|warm|duration|billed|memory|report)" || echo "No Lambda lifecycle events found"
              
            else
              echo "‚ùå No log streams found in $LOG_GROUP"
            fi
            
          else
            echo "‚ùå Log group not found: $LOG_GROUP"
            echo "üîç Available log groups matching pattern:"
            aws logs describe-log-groups --log-group-name-prefix "/aws/lambda/" --query 'logGroups[].[logGroupName]' --output text
          fi

          # 5. ENVIRONMENT AND DEPENDENCY CHECK
          echo ""
          echo "üîß Lambda Environment & Dependencies Analysis:"
          echo "=============================================="

          # Try to invoke Lambda directly to get more info
          echo "üîç Direct Lambda Invocation Test:"

          # Create simple test payload (skip complex JSON to avoid YAML issues)
          echo "Testing Lambda function directly with minimal payload..."
          aws lambda invoke \
            --function-name "$LAMBDA_FUNCTION" \
            --payload '{}' \
            --cli-read-timeout 30 \
            lambda_test_response.json

          echo "Lambda Response:"
          cat lambda_test_response.json 2>/dev/null | jq . || cat lambda_test_response.json 2>/dev/null

          echo ""
          echo "üîç API Gateway Information:"
          echo "=========================="
          # Try to find the API Gateway associated with the Lambda
          API_ID=$(aws apigatewayv2 get-apis --query 'Items[?Name==`hibiji-api`].ApiId' --output text)
          if [ "$API_ID" != "None" ] && [ -n "$API_ID" ]; then
            echo "API Gateway ID: $API_ID"
            aws apigatewayv2 get-api --api-id "$API_ID" --output table
            
            echo ""
            echo "API Gateway Routes:"
            aws apigatewayv2 get-routes --api-id "$API_ID" --output table
          else
            echo "API Gateway not found or not accessible"
          fi

      - name: Test website availability
        run: |
          # Get website URL from CloudFront distribution
          BUCKET_NAME="${{ needs.deploy-infrastructure.outputs.website-bucket }}"
          WEBSITE_URL=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='$BUCKET_NAME'].DomainName" \
            --output text)

          if [ ! -z "$WEBSITE_URL" ]; then
            echo "Testing website at: https://$WEBSITE_URL"
            if curl -f "https://$WEBSITE_URL"; then
              echo "‚úÖ Website health check passed"
            else
              echo "‚ùå Website health check failed"
              exit 1
            fi
          fi

  # =================================
  # Notification
  # =================================
  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [health-check, deploy-infrastructure]
    if: always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    steps:
      - name: Deployment notification
        run: |
          if [[ "${{ needs.health-check.result }}" == "success" ]]; then
            echo "üéâ Serverless deployment completed successfully!"
            echo "Frontend: Available via CloudFront"
            echo "API: ${{ needs.deploy-infrastructure.outputs.api-url }}"
          else
            echo "‚ùå Deployment failed or health checks did not pass"
            exit 1
          fi
