name: Deploy Serverless Architecture

on:
  push:
    branches:
      - main
      - "dev[0-9][0-9]"
      - "qa[0-9][0-9]"
      - "staging[0-9][0-9]"
      - "hotfix[0-9][0-9]"
  pull_request:
    branches:
      - main
      - "dev[0-9][0-9]"
      - "qa[0-9][0-9]"
      - "staging[0-9][0-9]"
      - "hotfix[0-9][0-9]"
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force deployment even if tests fail"
        required: false
        default: false
        type: boolean
      skip_tests:
        description: "Skip test execution for emergency deployments"
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  security-events: write
  actions: read
  contents: read

env:
  AWS_REGION: us-west-1
  NODE_VERSION: 20
  # Remove hardcoded DOMAIN - will be determined dynamically

# Prevent multiple runs from conflicting
concurrency:
  group: serverless-deployment-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  # ===========================================
  # Environment Detection & Setup
  # ===========================================
  detect-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      main_env: ${{ steps.env.outputs.main_env }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
      is_numbered_env: ${{ steps.env.outputs.is_numbered_env }}
      function_name: ${{ steps.env.outputs.function_name }}
      s3_bucket: ${{ steps.env.outputs.s3_bucket }}
      api_url: ${{ steps.env.outputs.api_url }}
      domain_name: ${{ steps.env.outputs.domain_name }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine Environment and Resources
        id: env
        run: |
          # Determine environment based on branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prod"
            MAIN_ENV="prod"
            SHOULD_DEPLOY="false"  # Main branch requires manual deployment
            IS_NUMBERED_ENV="false"
          elif [[ "${{ github.ref_name }}" =~ ^dev[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="dev"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          elif [[ "${{ github.ref_name }}" =~ ^qa[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="qa"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          elif [[ "${{ github.ref_name }}" =~ ^staging[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="staging"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          elif [[ "${{ github.ref_name }}" =~ ^hotfix[0-9][0-9]$ ]]; then
            ENVIRONMENT="${{ github.ref_name }}"
            MAIN_ENV="hotfix"
            SHOULD_DEPLOY="true"
            IS_NUMBERED_ENV="true"
          else
            echo "‚ùå Invalid branch name: ${{ github.ref_name }}"
            echo "Valid branches: main, dev01-dev99, qa01-qa99, staging01-staging99, hotfix01-hotfix99"
            exit 1
          fi

          # Generate dynamic resource names
          FUNCTION_NAME="$MAIN_ENV-$ENVIRONMENT-dpp-api"
          S3_BUCKET="$MAIN_ENV-$ENVIRONMENT-dpp-website"

          # Generate API URL dynamically based on environment pattern
          DOMAIN_NAME="${ENVIRONMENT}.hibiji.com"

          # Determine HIBIJI_API_URL based on existing resources or prediction
          API_URL="https://${ENVIRONMENT}-api.hibiji.com/v1"

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "main_env=$MAIN_ENV" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "is_numbered_env=$IS_NUMBERED_ENV" >> $GITHUB_OUTPUT
          echo "function_name=$FUNCTION_NAME" >> $GITHUB_OUTPUT
          echo "s3_bucket=$S3_BUCKET" >> $GITHUB_OUTPUT
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "domain_name=$DOMAIN_NAME" >> $GITHUB_OUTPUT

          echo "üéØ Environment: $ENVIRONMENT"
          echo "üèóÔ∏è Main Environment: $MAIN_ENV"
          echo "üöÄ Should Deploy: $SHOULD_DEPLOY"
          echo "üî¢ Is Numbered Environment: $IS_NUMBERED_ENV"
          echo "‚ö° Function Name: $FUNCTION_NAME"
          echo "ü™£ S3 Bucket: $S3_BUCKET"
          echo "üåê API URL: $API_URL"
          echo "üè° Domain Name: $DOMAIN_NAME"

  # ===========================================
  # Dependency Scanning (Security)
  # ===========================================
  dependency-scan:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    continue-on-error: true
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

  # ===========================================
  # Build Phase
  # ===========================================
  build-backend:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [detect-environment]
    outputs:
      backend-hash: ${{ steps.hash.outputs.backend-hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: "package-lock.json"

      - name: Install dependencies
        run: npm ci

      - name: Build workspace packages
        run: |
          echo "üîß Building workspace packages..."
          npm run build --workspace=@digital-persona/database
          npm run build --workspace=@digital-persona/shared

      - name: Build backend for Lambda
        working-directory: apps/server
        run: |
          echo "üì¶ Building backend for Lambda deployment..."
          npm run build:lambda

      - name: Generate build hash
        id: hash
        run: |
          HASH=$(echo "${{ github.sha }}-${{ needs.detect-environment.outputs.environment }}" | sha256sum | cut -d' ' -f1 | head -c 8)
          echo "backend-hash=$HASH" >> $GITHUB_OUTPUT
          echo "üìã Build hash: $HASH"

      - name: Upload backend artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-${{ needs.detect-environment.outputs.environment }}-${{ steps.hash.outputs.backend-hash }}
          path: |
            apps/server/lambda-dist/index.js
            apps/server/lambda-dist/package.json

  build-frontend:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [detect-environment]
    outputs:
      frontend-hash: ${{ steps.hash.outputs.frontend-hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: "package-lock.json"

      - name: Install dependencies
        run: npm ci

      - name: Build workspace packages
        run: |
          echo "üîß Building workspace packages..."
          npm run build --workspace=@digital-persona/database
          npm run build --workspace=@digital-persona/shared

      - name: Build frontend for static hosting
        working-directory: apps/web
        env:
          NEXT_PUBLIC_API_URL: ${{ needs.detect-environment.outputs.api_url }}
          NEXT_BUILD_EXPORT: "true"
        run: |
          echo "üì¶ Building frontend for static hosting..."
          echo "üåê API URL: $NEXT_PUBLIC_API_URL"
          echo "üì¶ Export mode: Static export for S3"
          npm run build

      - name: Generate build hash
        id: hash
        run: |
          HASH=$(echo "${{ github.sha }}-${{ needs.detect-environment.outputs.environment }}" | sha256sum | cut -d' ' -f1 | head -c 8)
          echo "frontend-hash=$HASH" >> $GITHUB_OUTPUT
          echo "üìã Build hash: $HASH"

      - name: Upload frontend artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-${{ needs.detect-environment.outputs.environment }}-${{ steps.hash.outputs.frontend-hash }}
          path: apps/web/out/

  # ===========================================
  # Infrastructure Deployment
  # ===========================================
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-environment, dependency-scan]
    if: ${{ needs.detect-environment.outputs.should_deploy == 'true' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 45
    environment: ${{ needs.detect-environment.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Cache Terraform
        uses: actions/cache@v4
        with:
          path: |
            .terraform
            .terraform.lock.hcl
          key: ${{ runner.os }}-terraform-serverless-${{ hashFiles('terraform/**/*.tf') }}

      - name: Terraform Init and Plan
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        env:
          ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
          MAIN_ENV: ${{ needs.detect-environment.outputs.main_env }}
          PROJECT_NAME: "dpp"
        run: |
          echo "üöÄ Step 1: Terraform Initialization..."
          terraform init

          echo "üéØ Step 2: Variables Configuration..."
          echo "Environment: $ENVIRONMENT"
          echo "Main Environment: $MAIN_ENV"

          # Create tfvars file
          cat > environment.auto.tfvars << EOF
          environment = "$MAIN_ENV"
          sub_environment = "$ENVIRONMENT"
          project_name = "$PROJECT_NAME"
          domain_name = "hibiji.com"
          aws_region = "${{ env.AWS_REGION }}"
          alert_emails = ["alerts@maras.co"]
          EOF

          echo "üìã Step 3: Terraform Planning..."
          terraform plan -var-file="environment.auto.tfvars" -out=tfplan

      - name: Import Existing Resources
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        env:
          ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
          MAIN_ENV: ${{ needs.detect-environment.outputs.main_env }}
          PROJECT_NAME: "dpp"
        run: |
          echo "üì• Step 3: Importing existing resources into Terraform state..."

          # Helper function for safe imports
          safe_import() {
            local resource_address="$1"
            local resource_id="$2"
            local resource_type="$3"
            local description="$4"
            
            echo "üîç Checking if $description exists in state..."
            if ! terraform state show "$resource_address" >/dev/null 2>&1; then
              echo "üì• Importing $description: $resource_id"
              if terraform import "$resource_address" "$resource_id" 2>/dev/null; then
                echo "‚úÖ Successfully imported $description"
              else
                echo "‚ö†Ô∏è Failed to import $description (may not exist or lack permissions)"
              fi
            else
              echo "‚úÖ $description already in state"
            fi
          }

          # Import Route53 hosted zone (shared across environments)
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones --query 'HostedZones[?Name==`hibiji.com.`].Id' --output text | sed 's|/hostedzone/||')
          if [ ! -z "$HOSTED_ZONE_ID" ] && [ "$HOSTED_ZONE_ID" != "None" ]; then
            safe_import "data.aws_route53_zone.main" "$HOSTED_ZONE_ID" "hosted_zone" "Route53 hosted zone"
          fi

          echo "‚úÖ Resource import completed"

      - name: Apply Terraform Configuration
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        env:
          ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
          MAIN_ENV: ${{ needs.detect-environment.outputs.main_env }}
          PROJECT_NAME: "dpp"
        run: |
          echo "üèóÔ∏è Step 4: Applying Terraform configuration..."

          # Get plan exit code to check if changes are needed
          PLAN_EXIT_CODE=0
          terraform plan -var-file="environment.auto.tfvars" -detailed-exitcode -out=tfplan || PLAN_EXIT_CODE=$?

          if [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "üöÄ Step 4: Applying Terraform configuration..."

            # First attempt: Full apply with timeout
            echo "üéØ Attempt 1: Full Terraform apply..."
            if timeout 1800 terraform apply -auto-approve -lock-timeout=300s tfplan; then
              echo "‚úÖ Full Terraform apply completed successfully!"
            else
              echo "‚ö†Ô∏è Full apply failed, trying targeted deployment..."
              
              # Second attempt: Core infrastructure first
              echo "üèóÔ∏è Attempt 2: Core infrastructure deployment..."
              
              # Apply VPC and networking first
              terraform apply -auto-approve -lock-timeout=300s \
                -target=aws_vpc.main \
                -target=aws_subnet.private \
                -target=aws_internet_gateway.main \
                -target=aws_security_group.database \
                -target=aws_security_group.lambda || echo "‚ö†Ô∏è VPC deployment issues"
              
              # Apply secrets and database
              terraform apply -auto-approve -lock-timeout=300s \
                -target=aws_secretsmanager_secret.jwt_secret \
                -target=aws_secretsmanager_secret.database_password \
                -target=aws_secretsmanager_secret_version.jwt_secret \
                -target=aws_secretsmanager_secret_version.database_password \
                -target=aws_db_subnet_group.database \
                -target=aws_rds_cluster.database \
                -target=aws_rds_cluster_instance.database || echo "‚ö†Ô∏è Database deployment issues"
              
              # Apply S3 buckets
              terraform apply -auto-approve -lock-timeout=300s \
                -target=aws_s3_bucket.uploads \
                -target=module.s3_website \
                -target=module.lambda_backend.aws_s3_bucket.lambda_deployments || echo "‚ö†Ô∏è S3 deployment issues"
              
              # Apply serverless components
              terraform apply -auto-approve -lock-timeout=300s \
                -target=module.lambda_backend \
                -target=module.api_gateway || echo "‚ö†Ô∏è Serverless deployment issues"
              
              # Apply DNS records last
              terraform apply -auto-approve -lock-timeout=300s \
                -target=aws_route53_record.website \
                -target=aws_route53_record.api || echo "‚ö†Ô∏è DNS deployment issues"
            fi
          else
            echo "‚úÖ No infrastructure changes needed (plan exit code: $PLAN_EXIT_CODE)"
          fi

      - name: Verify Infrastructure
        working-directory: terraform/environments/${{ needs.detect-environment.outputs.main_env }}
        run: |
          echo "üîç Step 5: Verifying infrastructure deployment..."

          # Get outputs
          terraform output -json > outputs.json

          echo "üìã Terraform Outputs:"
          cat outputs.json | jq .

          # Verify key resources exist
          echo "üîç Verifying key resources..."

          # Check Lambda function
          FUNCTION_NAME=$(terraform output -raw lambda_function_name 2>/dev/null || echo "")
          if [ ! -z "$FUNCTION_NAME" ]; then
            echo "‚úÖ Lambda function: $FUNCTION_NAME"
          fi

          # Check S3 website bucket
          WEBSITE_BUCKET=$(terraform output -raw website_bucket_name 2>/dev/null || echo "")
          if [ ! -z "$WEBSITE_BUCKET" ]; then
            echo "‚úÖ Website S3 bucket: $WEBSITE_BUCKET"
          fi

          # Check API Gateway URL
          API_URL=$(terraform output -raw api_url 2>/dev/null || echo "")
          if [ ! -z "$API_URL" ]; then
            echo "‚úÖ API Gateway URL: $API_URL"
          fi

      - name: Upload Terraform outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ needs.detect-environment.outputs.environment }}
          path: terraform/environments/${{ needs.detect-environment.outputs.main_env }}/outputs.json

  # ===========================================
  # Application Deployment
  # ===========================================
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [detect-environment, deploy-infrastructure, build-backend]
    if: ${{ needs.detect-environment.outputs.should_deploy == 'true' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download backend artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-${{ needs.detect-environment.outputs.environment }}-${{ needs.build-backend.outputs.backend-hash }}

      - name: Locate and prepare Lambda files
        run: |
          echo "üì¶ Locating Lambda bundle files after artifact download..."
          echo "üìÅ Current directory contents:"
          ls -la

          # Find index.js location and move to current directory if needed
          INDEX_JS_PATH=$(find . -name "index.js" -type f | head -1)
          PACKAGE_JSON_PATH=$(find . -name "package.json" -path "*/lambda-dist/*" -type f | head -1)

          if [ -z "$INDEX_JS_PATH" ]; then
            echo "‚ùå index.js not found anywhere"
            echo "üìÅ Available files:"
            find . -name "*.js" -o -name "*.json" | head -10
            exit 1
          fi

          echo "üìç Found index.js at: $INDEX_JS_PATH"

          # Move files to current directory if they're in subdirectories
          if [ "$INDEX_JS_PATH" != "./index.js" ]; then
            echo "üì¶ Moving Lambda files to current directory..."
            cp "$INDEX_JS_PATH" ./index.js
            
            if [ -n "$PACKAGE_JSON_PATH" ]; then
              echo "üìç Found package.json at: $PACKAGE_JSON_PATH"
              cp "$PACKAGE_JSON_PATH" ./package.json
            fi
          fi

          echo "‚úÖ Lambda files prepared:"
          ls -la index.js package.json

      - name: Create Lambda deployment package
        run: |
          echo "üì¶ Creating Lambda deployment package from bundled output..."

          # Create deployment zip from current directory (which contains the bundled output)
          echo "üì¶ Creating deployment zip from bundled files..."
          zip -r lambda-deployment.zip . -x "*.DS_Store*" "*.git*"

          echo "‚úÖ Lambda deployment package created successfully"
          echo "üìä Package contents:"
          unzip -l lambda-deployment.zip

      - name: Deploy Lambda function
        run: |
          # Use dynamic function name from environment detection
          FUNCTION_NAME="${{ needs.detect-environment.outputs.function_name }}"

          echo "üîÑ Updating Lambda function: $FUNCTION_NAME"

          # Wait for Lambda to be ready
          check_lambda_ready() {
            local status=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text 2>/dev/null)
            echo "Lambda status: $status"
            [[ "$status" == "Active" ]]
          }

          # Wait for Lambda to be ready before updating
          echo "‚è≥ Waiting for Lambda to be ready..."
          for i in {1..30}; do
            if check_lambda_ready; then
              echo "‚úÖ Lambda is ready for update"
              break
            fi
            echo "‚è≥ Waiting... (attempt $i/30)"
            sleep 10
          done

          # Update Lambda with retry logic
          update_lambda() {
            local max_attempts=5
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "üîÑ Attempting Lambda update (attempt $attempt/$max_attempts)..."
              
              if aws lambda update-function-code --function-name $FUNCTION_NAME --zip-file fileb://lambda-deployment.zip; then
                echo "‚úÖ Lambda update successful"
                return 0
              else
                echo "‚ùå Lambda update failed (attempt $attempt/$max_attempts)"
                
                if [ $attempt -lt $max_attempts ]; then
                  echo "‚è≥ Waiting before retry..."
                  sleep $((attempt * 10))
                fi
                
                attempt=$((attempt + 1))
              fi
            done
            
            echo "‚ùå All Lambda update attempts failed"
            return 1
          }

          update_lambda

      - name: Verify Lambda permissions after deployment
        run: |
          FUNCTION_NAME="${{ needs.detect-environment.outputs.function_name }}"

          echo "üîç Verifying Lambda function configuration..."

          # Get function configuration
          aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.{Runtime:Runtime,Timeout:Timeout,MemorySize:MemorySize,State:State}' --output table

          # Test Lambda function
          echo "üß™ Testing Lambda function..."
          aws lambda invoke --function-name $FUNCTION_NAME --payload '{"httpMethod":"GET","path":"/health"}' response.json

          if [ -f response.json ]; then
            echo "üìã Lambda response:"
            cat response.json
          fi

  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [detect-environment, deploy-infrastructure, build-frontend]
    if: ${{ needs.detect-environment.outputs.should_deploy == 'true' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download frontend artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-${{ needs.detect-environment.outputs.environment }}-${{ needs.build-frontend.outputs.frontend-hash }}

      - name: Download Terraform outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs-${{ needs.detect-environment.outputs.environment }}

      - name: Deploy to S3
        run: |
          # Extract S3 bucket name from Terraform outputs
          if [ -f outputs.json ]; then
            S3_BUCKET=$(cat outputs.json | jq -r '.website_bucket_name.value // empty')
          fi

          # Fallback to detected bucket name
          if [ -z "$S3_BUCKET" ]; then
            S3_BUCKET="${{ needs.detect-environment.outputs.s3_bucket }}"
          fi

          echo "üì§ Deploying frontend to S3 bucket: $S3_BUCKET"
          echo "üìÅ Current directory contents:"
          ls -la

          # Sync frontend files to S3
          echo "üîÑ Syncing files to S3..."
          if [ -f "index.html" ]; then
            echo "‚úÖ Frontend build output found (files extracted to current directory)"
            aws s3 sync . s3://$S3_BUCKET/ --delete --cache-control "max-age=31536000" --exclude "*.html" --exclude "*.json" --exclude "outputs.json"
            aws s3 sync . s3://$S3_BUCKET/ --delete --cache-control "max-age=0" --include "*.html" --include "*.json" --exclude "outputs.json"
          else
            echo "‚ùå Frontend build output not found"
            echo "üìÅ Available files:"
            ls -la
            exit 1
          fi

          echo "‚úÖ Frontend deployment completed"

      - name: Invalidate CloudFront Cache
        run: |
          # Extract CloudFront distribution ID from AWS
          DISTRIBUTION_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?contains(Aliases.Items || [''], '${{ needs.detect-environment.outputs.domain_name }}')].Id" --output text)

          if [ ! -z "$DISTRIBUTION_ID" ]; then
            echo "üîÑ Invalidating CloudFront cache for distribution: $DISTRIBUTION_ID"
            aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"
          else
            echo "‚ö†Ô∏è CloudFront distribution not found for domain: ${{ needs.detect-environment.outputs.domain_name }}"
          fi

  # ===========================================
  # Health Checks & Verification
  # ===========================================
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [detect-environment, deploy-backend, deploy-frontend]
    if: ${{ needs.detect-environment.outputs.should_deploy == 'true' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Health Check API
        run: |
          API_URL="${{ needs.detect-environment.outputs.api_url }}"
          echo "üè• Testing API health endpoint: $API_URL/health"

          # Wait for API to be ready
          for i in {1..10}; do
            if curl -f "$API_URL/health" -m 10; then
              echo "‚úÖ API health check passed"
              break
            else
              echo "‚è≥ API not ready, waiting... (attempt $i/10)"
              sleep 15
            fi
          done

      - name: Health Check Website
        run: |
          WEBSITE_URL="https://${{ needs.detect-environment.outputs.domain_name }}"
          echo "üåê Testing website: $WEBSITE_URL"

          # Wait for website to be ready
          for i in {1..10}; do
            if curl -f "$WEBSITE_URL" -m 10; then
              echo "‚úÖ Website health check passed"
              break
            else
              echo "‚è≥ Website not ready, waiting... (attempt $i/10)"
              sleep 15
            fi
          done

      - name: Deployment Summary
        run: |
          echo "üéâ Deployment Summary"
          echo "===================="
          echo "Environment: ${{ needs.detect-environment.outputs.environment }}"
          echo "API URL: ${{ needs.detect-environment.outputs.api_url }}"
          echo "Website URL: https://${{ needs.detect-environment.outputs.domain_name }}"
          echo "Function Name: ${{ needs.detect-environment.outputs.function_name }}"
          echo "S3 Bucket: ${{ needs.detect-environment.outputs.s3_bucket }}"
          echo ""
          echo "‚úÖ Serverless deployment completed successfully!"
