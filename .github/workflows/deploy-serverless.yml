name: Deploy Serverless Architecture

on:
  push:
    branches:
      - dev01
      - dev02
      - main
      - staging
      - prod
  pull_request:
    branches:
      - dev01
      - dev02
      - main
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force deployment even if tests fail"
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  security-events: write
  actions: read
  contents: read

env:
  AWS_REGION: us-west-1
  NODE_VERSION: 20

jobs:
  # =================================
  # Build and Test
  # =================================
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint --if-present

      - name: Run type checking
        run: npm run type-check --if-present

      - name: Run tests
        run: npm run test --if-present

  # =================================
  # Build Frontend for Static Export
  # =================================
  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    needs: build-and-test

    outputs:
      frontend-hash: ${{ steps.frontend-hash.outputs.hash }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build shared packages
        run: |
          npm run build --workspace=@digital-persona/shared
          npm run build --workspace=@digital-persona/database

      - name: Build frontend for static export
        env:
          NODE_ENV: production
          NEXT_BUILD_EXPORT: true
          # Set API URL based on branch
          NEXT_PUBLIC_API_URL: >-
            ${{ 
              github.ref == 'refs/heads/main' && secrets.API_URL_MAIN ||
              github.ref == 'refs/heads/staging' && secrets.API_URL_STAGING ||
              github.ref == 'refs/heads/prod' && secrets.API_URL_PROD ||
              secrets.API_URL_DEV 
            }}
        run: |
          cd apps/web
          echo "üèóÔ∏è Building frontend for static export..."
          npm run build
          echo "‚úÖ Frontend build completed"

      - name: Validate build output
        run: |
          cd apps/web
          if [ ! -d "out" ]; then
            echo "‚ùå Error: 'out' directory not found after build"
            echo "üìÅ Available directories:"
            ls -la
            exit 1
          fi

          if [ -z "$(ls -A out)" ]; then
            echo "‚ùå Error: 'out' directory is empty"
            exit 1
          fi

          echo "‚úÖ Build output validation passed"
          echo "üìÅ Files in out directory:"
          ls -la out/

      - name: Generate frontend hash
        id: frontend-hash
        run: |
          cd apps/web
          if [ ! -d "out" ] || [ -z "$(ls -A out)" ]; then
            echo "‚ùå Frontend build output is empty! Failing the job."
            exit 1
          fi

          hash=$(find out -type f -exec sha256sum {} \; | sha256sum | cut -d' ' -f1)
          echo "hash=${hash:0:8}" >> $GITHUB_OUTPUT
          echo "‚úÖ Generated frontend hash: ${hash:0:8}"

      - name: Upload frontend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ steps.frontend-hash.outputs.hash }}
          path: apps/web/out/
          retention-days: 7

  # =================================
  # Build Backend Lambda Package
  # =================================
  build-backend:
    name: Build Backend Lambda
    runs-on: ubuntu-latest
    needs: build-and-test

    outputs:
      backend-hash: ${{ steps.backend-hash.outputs.hash }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build shared packages
        run: |
          npm run build --workspace=@digital-persona/shared
          npm run build --workspace=@digital-persona/database

      - name: Build backend for Lambda
        run: |
          cd apps/server
          npm run build

      - name: Create Lambda deployment package
        run: |
          # Install production dependencies at root level (for workspaces)
          npm ci --omit=dev --ignore-scripts

          cd apps/server
          # Create deployment directory
          mkdir -p deployment

          # Copy built files
          cp -r dist/* deployment/

          # Copy package.json for Lambda runtime
          cp package.json deployment/

          # Copy production node_modules from workspace root
          # Only copy the specific dependencies needed by the server package
          mkdir -p deployment/node_modules

          # Copy workspace packages that server depends on
          if [ -d "../../node_modules/@digital-persona" ]; then
            cp -r ../../node_modules/@digital-persona deployment/node_modules/
          fi

          # Copy other essential dependencies (you can expand this list as needed)
          for pkg in "@trpc" "zod" "drizzle-orm" "express" "cors" "bcryptjs" "jsonwebtoken" "superjson" "serverless-http" "@aws-sdk"; do
            if [ -d "../../node_modules/$pkg" ]; then
              cp -r "../../node_modules/$pkg" deployment/node_modules/
            fi
          done

          # Create zip file
          cd deployment
          zip -r ../lambda-deployment.zip .
          cd ..

          # Clean up
          rm -rf deployment

      - name: Generate backend hash
        id: backend-hash
        run: |
          cd apps/server
          hash=$(sha256sum lambda-deployment.zip | cut -d' ' -f1)
          echo "hash=${hash:0:8}" >> $GITHUB_OUTPUT

      - name: Upload backend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build-${{ steps.backend-hash.outputs.hash }}
          path: apps/server/lambda-deployment.zip
          retention-days: 7

  # =================================
  # Deploy Infrastructure
  # =================================
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [build-frontend, build-backend]
    if: github.event_name == 'push'

    environment: >-
      ${{ 
        github.ref == 'refs/heads/main' && 'main' ||
        github.ref == 'refs/heads/staging' && 'staging' ||
        github.ref == 'refs/heads/prod' && 'prod' ||
        'dev'
      }}

    outputs:
      website-bucket: ${{ steps.terraform-output.outputs.website-bucket }}
      api-url: ${{ steps.terraform-output.outputs.api-url }}
      lambda-function: ${{ steps.terraform-output.outputs.lambda-function }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-ServerlessDeploy

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Determine environment and sub-environment
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=main" >> $GITHUB_OUTPUT
            echo "sub_environment=main" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "sub_environment=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/prod" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "sub_environment=prod" >> $GITHUB_OUTPUT
          else
            # Extract sub-environment from branch name (e.g., dev01, dev02)
            branch_name="${{ github.ref_name }}"
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "sub_environment=${branch_name}" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Init
        run: |
          cd terraform/environments/${{ steps.env.outputs.environment }}
          terraform init

      - name: Terraform Plan
        run: |
          cd terraform/environments/${{ steps.env.outputs.environment }}
          terraform plan \
            -var="sub_environment=${{ steps.env.outputs.sub_environment }}" \
            -input=false \
            -out=tfplan

      - name: Terraform Apply
        run: |
          cd terraform/environments/${{ steps.env.outputs.environment }}
          terraform apply -input=false tfplan

      - name: Get Terraform outputs
        id: terraform-output
        run: |
          cd terraform/environments/${{ steps.env.outputs.environment }}
          echo "website-bucket=$(terraform output -raw website_bucket_name)" >> $GITHUB_OUTPUT
          echo "api-url=$(terraform output -raw api_url)" >> $GITHUB_OUTPUT
          echo "lambda-function=$(terraform output -raw lambda_function_name)" >> $GITHUB_OUTPUT

  # =================================
  # Deploy Frontend to S3
  # =================================
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [build-frontend, deploy-infrastructure]
    if: github.event_name == 'push'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-FrontendDeploy

      - name: Download frontend build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ needs.build-frontend.outputs.frontend-hash }}
          path: frontend-build/

      - name: Deploy to S3
        run: |
          aws s3 sync frontend-build/ s3://${{ needs.deploy-infrastructure.outputs.website-bucket }}/ \
            --delete \
            --cache-control "public, max-age=31536000" \
            --exclude "*.html" \
            --exclude "*.json"

          # Deploy HTML files with shorter cache
          aws s3 sync frontend-build/ s3://${{ needs.deploy-infrastructure.outputs.website-bucket }}/ \
            --delete \
            --cache-control "public, max-age=3600" \
            --include "*.html" \
            --include "*.json"

      - name: Invalidate CloudFront cache
        run: |
          # Get CloudFront distribution ID
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='${{ needs.deploy-infrastructure.outputs.website-bucket }}'].Id" \
            --output text)

          if [ ! -z "$DISTRIBUTION_ID" ]; then
            aws cloudfront create-invalidation \
              --distribution-id $DISTRIBUTION_ID \
              --paths "/*"
          fi

  # =================================
  # Deploy Backend Lambda
  # =================================
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [build-backend, deploy-infrastructure]
    if: github.event_name == 'push'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-BackendDeploy

      - name: Download backend build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build-${{ needs.build-backend.outputs.backend-hash }}
          path: backend-build/

      - name: Update Lambda function
        run: |
          aws lambda update-function-code \
            --function-name ${{ needs.deploy-infrastructure.outputs.lambda-function }} \
            --zip-file fileb://backend-build/lambda-deployment.zip

      - name: Wait for Lambda update to complete
        run: |
          aws lambda wait function-updated \
            --function-name ${{ needs.deploy-infrastructure.outputs.lambda-function }}

  # =================================
  # Health Check and Smoke Tests
  # =================================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-backend, deploy-infrastructure]
    if: github.event_name == 'push'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-HealthCheck

      - name: Test API health endpoint with detailed error capture
        run: |
          API_URL="${{ needs.deploy-infrastructure.outputs.api-url }}"
          echo "üîç Testing API health endpoint with detailed error capture"
          echo "================================================"
          echo "API URL: $API_URL/health"
          echo ""

          # Function to perform detailed health check
          perform_health_check() {
            local attempt=$1
            echo "üîç Health Check Attempt $attempt/10"
            echo "============================="
            
            # Create temporary files for response capture
            local response_body=$(mktemp)
            local response_headers=$(mktemp)
            
            # Perform request with full details capture
            local http_status=$(curl -s -w "%{http_code}" \
              --connect-timeout 10 \
              --max-time 30 \
              --dump-header "$response_headers" \
              --output "$response_body" \
              "$API_URL/health" 2>&1)
            
            local curl_exit_code=$?
            
            echo "üìä Request Details:"
            echo "  URL: $API_URL/health"
            echo "  HTTP Status: $http_status"
            echo "  Curl Exit Code: $curl_exit_code"
            echo "  Timestamp: $(date -u)"
            echo ""
            
            # Display response headers
            echo "üìã Response Headers:"
            echo "==================="
            if [ -f "$response_headers" ] && [ -s "$response_headers" ]; then
              cat "$response_headers"
            else
              echo "  (No headers captured)"
            fi
            echo ""
            
            # Display response body
            echo "üìÑ Response Body:"
            echo "================="
            if [ -f "$response_body" ] && [ -s "$response_body" ]; then
              echo "  Content Length: $(wc -c < "$response_body") bytes"
              echo "  Raw Response:"
              echo "  ============="
              cat "$response_body" | head -100  # Limit to first 100 lines
              echo ""
              
              # Try to pretty-print JSON if it's JSON
              if cat "$response_body" | jq . >/dev/null 2>&1; then
                echo "  Pretty-printed JSON:"
                echo "  ==================="
                cat "$response_body" | jq .
              fi
            else
              echo "  (No response body captured)"
            fi
            echo ""
            
            # Analyze the result
            if [ "$curl_exit_code" -eq 0 ] && [ "$http_status" = "200" ]; then
              echo "‚úÖ SUCCESS: API health check passed!"
              cleanup_temp_files "$response_body" "$response_headers"
              return 0
            elif [ "$curl_exit_code" -ne 0 ]; then
              echo "‚ùå CURL ERROR: Network/connection issue (exit code: $curl_exit_code)"
              if [ "$curl_exit_code" -eq 7 ]; then
                echo "   Failed to connect to host"
              elif [ "$curl_exit_code" -eq 28 ]; then
                echo "   Operation timeout"
              elif [ "$curl_exit_code" -eq 6 ]; then
                echo "   Couldn't resolve host"
              fi
            elif [ "$http_status" = "500" ]; then
              echo "‚ùå HTTP 500 ERROR: Internal Server Error"
              echo "üîç DEBUGGING INFORMATION:"
              echo "========================"
              
              # Check if it's a Lambda error
              if grep -q "errorType\|errorMessage" "$response_body" 2>/dev/null; then
                echo "üö® Lambda Function Error Detected:"
                cat "$response_body" | jq -r '.errorType // "Unknown"' 2>/dev/null || echo "  Could not parse error type"
                echo "Error Message:"
                cat "$response_body" | jq -r '.errorMessage // "Unknown"' 2>/dev/null || cat "$response_body"
                echo ""
                echo "Stack Trace:"
                cat "$response_body" | jq -r '.trace[]? // empty' 2>/dev/null || echo "  No stack trace available"
              fi
              
              # Check for common Lambda issues
              if grep -q "Task timed out" "$response_body" 2>/dev/null; then
                echo "‚è±Ô∏è Lambda Timeout Detected"
              elif grep -q "Runtime exited with error" "$response_body" 2>/dev/null; then
                echo "üî• Lambda Runtime Error Detected"
              elif grep -q "Cannot find module" "$response_body" 2>/dev/null; then
                echo "üì¶ Missing Node.js Module Detected"
              elif grep -q "Permission denied" "$response_body" 2>/dev/null; then
                echo "üîí Permission Error Detected"
              fi
              
            elif [ "$http_status" = "502" ]; then
              echo "‚ùå HTTP 502 ERROR: Bad Gateway (API Gateway issue)"
            elif [ "$http_status" = "503" ]; then
              echo "‚ùå HTTP 503 ERROR: Service Unavailable"
            elif [ "$http_status" = "504" ]; then
              echo "‚ùå HTTP 504 ERROR: Gateway Timeout"
            else
              echo "‚ùå HTTP $http_status ERROR: Unexpected status code"
            fi
            
            cleanup_temp_files "$response_body" "$response_headers"
            return 1
          }

          # Function to cleanup temporary files
          cleanup_temp_files() {
            [ -f "$1" ] && rm -f "$1"
            [ -f "$2" ] && rm -f "$2"
          }

          # Retry logic with detailed reporting
          HEALTH_CHECK_PASSED=false
          for i in {1..10}; do
            echo ""
            if perform_health_check $i; then
              HEALTH_CHECK_PASSED=true
              break
            else
              if [ $i -lt 10 ]; then
                echo "‚è≥ Waiting 30 seconds before next attempt..."
                sleep 30
              fi
            fi
          done

          echo ""
          echo "üéØ Final Health Check Result:"
          echo "============================="
          if [ "$HEALTH_CHECK_PASSED" = "true" ]; then
                       echo "‚úÖ API health check PASSED after $i attempts"
           else
             echo "‚ùå API health check FAILED after 10 attempts"
             echo "üí° Next steps for debugging:"
             echo "  1. Check Lambda function logs in CloudWatch"
             echo "  2. Verify Lambda function configuration"
             echo "  3. Check API Gateway configuration"
             echo "  4. Review Lambda deployment package"
             exit 1
           fi

      - name: Capture Lambda function logs for debugging
        if: failure()
        run: |
          echo "üîç Capturing Lambda Function Logs for Debugging"
          echo "=============================================="

          LAMBDA_FUNCTION="${{ needs.deploy-infrastructure.outputs.lambda-function }}"
          echo "Lambda Function: $LAMBDA_FUNCTION"
          echo ""

          # Get the log group name for the Lambda function
          LOG_GROUP="/aws/lambda/$LAMBDA_FUNCTION"
          echo "Log Group: $LOG_GROUP"
          echo ""

          # Check if log group exists
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[0].logGroupName' --output text | grep -q "$LOG_GROUP"; then
            echo "‚úÖ Log group found: $LOG_GROUP"
            echo ""
            
            # Get recent log streams (last 1 hour)
            echo "üìã Recent Log Streams:"
            echo "====================="
            RECENT_STREAMS=$(aws logs describe-log-streams \
              --log-group-name "$LOG_GROUP" \
              --order-by LastEventTime \
              --descending \
              --max-items 5 \
              --query 'logStreams[].{streamName:logStreamName,lastEvent:lastEventTime}' \
              --output table)
            echo "$RECENT_STREAMS"
            echo ""
            
            # Get the most recent log stream
            LATEST_STREAM=$(aws logs describe-log-streams \
              --log-group-name "$LOG_GROUP" \
              --order-by LastEventTime \
              --descending \
              --max-items 1 \
              --query 'logStreams[0].logStreamName' \
              --output text)
            
            if [ "$LATEST_STREAM" != "None" ] && [ -n "$LATEST_STREAM" ]; then
              echo "üîç Latest Log Stream: $LATEST_STREAM"
              echo ""
              
              # Get recent log events (last 30 minutes)
              echo "üìÑ Recent Log Events (last 30 minutes):"
              echo "======================================="
              
              # Calculate timestamp for 30 minutes ago
              THIRTY_MIN_AGO=$(date -d '30 minutes ago' +%s)000  # CloudWatch expects milliseconds
              
              aws logs get-log-events \
                --log-group-name "$LOG_GROUP" \
                --log-stream-name "$LATEST_STREAM" \
                --start-time "$THIRTY_MIN_AGO" \
                --query 'events[].[timestamp,message]' \
                --output text | while IFS=$'\t' read -r timestamp message; do
                  # Convert timestamp to human readable
                  readable_time=$(date -d "@$((timestamp/1000))" "+%Y-%m-%d %H:%M:%S UTC")
                  echo "[$readable_time] $message"
                done
              
              echo ""
              echo "üîç Filtering for ERROR and WARN messages:"
              echo "========================================="
              aws logs get-log-events \
                --log-group-name "$LOG_GROUP" \
                --log-stream-name "$LATEST_STREAM" \
                --start-time "$THIRTY_MIN_AGO" \
                --query 'events[?contains(message, `ERROR`) || contains(message, `WARN`) || contains(message, `error`) || contains(message, `Error`)].[timestamp,message]' \
                --output text | while IFS=$'\t' read -r timestamp message; do
                  readable_time=$(date -d "@$((timestamp/1000))" "+%Y-%m-%d %H:%M:%S UTC")
                  echo "[$readable_time] $message"
                done
              
            else
              echo "‚ùå No log streams found in $LOG_GROUP"
            fi
            
          else
            echo "‚ùå Log group not found: $LOG_GROUP"
            echo "üîç Available log groups matching pattern:"
            aws logs describe-log-groups --log-group-name-prefix "/aws/lambda/" --query 'logGroups[].[logGroupName]' --output text
          fi

          echo ""
          echo "üîç Lambda Function Configuration:"
          echo "================================="
          aws lambda get-function-configuration --function-name "$LAMBDA_FUNCTION" --output table

          echo ""
          echo "üîç API Gateway Information:"
          echo "=========================="
          # Try to find the API Gateway associated with the Lambda
          API_ID=$(aws apigatewayv2 get-apis --query 'Items[?Name==`hibiji-api`].ApiId' --output text)
          if [ "$API_ID" != "None" ] && [ -n "$API_ID" ]; then
            echo "API Gateway ID: $API_ID"
            aws apigatewayv2 get-api --api-id "$API_ID" --output table
          else
            echo "API Gateway not found or not accessible"
          fi

      - name: Test website availability
        run: |
          # Get website URL from CloudFront distribution
          BUCKET_NAME="${{ needs.deploy-infrastructure.outputs.website-bucket }}"
          WEBSITE_URL=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='$BUCKET_NAME'].DomainName" \
            --output text)

          if [ ! -z "$WEBSITE_URL" ]; then
            echo "Testing website at: https://$WEBSITE_URL"
            if curl -f "https://$WEBSITE_URL"; then
              echo "‚úÖ Website health check passed"
            else
              echo "‚ùå Website health check failed"
              exit 1
            fi
          fi

  # =================================
  # Notification
  # =================================
  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [health-check, deploy-infrastructure]
    if: always() && github.event_name == 'push'

    steps:
      - name: Deployment notification
        run: |
          if [[ "${{ needs.health-check.result }}" == "success" ]]; then
            echo "üéâ Serverless deployment completed successfully!"
            echo "Frontend: Available via CloudFront"
            echo "API: ${{ needs.deploy-infrastructure.outputs.api-url }}"
          else
            echo "‚ùå Deployment failed or health checks did not pass"
            exit 1
          fi
