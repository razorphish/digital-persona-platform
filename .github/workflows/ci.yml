name: Continuous Integration (Optimized)

on:
  push:
    branches: [main, "dev*", "qa*", "staging*", "hotfix*"]
  pull_request:
    branches: [main, "dev*", "qa*", "staging*", "hotfix*"]

permissions:
  id-token: write
  security-events: write
  actions: read
  contents: read

env:
  AWS_REGION: us-west-1
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "18"

# Prevent multiple CI runs from conflicting
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Security Scanning (runs in parallel with tests)
  security-scan:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for secret scanning

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: Run Secret Scanner
        uses: trufflesecurity/trufflehog@main
        with:
          path: .
          base: HEAD~1
          head: HEAD

  # Backend Tests (runs in parallel with frontend tests)
  backend-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        python-version: ["3.11"]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            ~/.cache/pytest
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}-${{ matrix.python-version }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}-
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio pytest-xdist

      - name: Run backend tests with coverage
        run: |
          python -m pytest tests/ -v --cov=app --cov-report=xml --cov-report=term-missing -n auto

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        if: always() && github.event_name != 'pull_request'
        with:
          file: ./coverage.xml
          flags: backend
          name: backend-coverage
          fail_ci_if_error: false
          verbose: true
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-coverage-reports
          path: |
            coverage.xml
            .coverage
          retention-days: 30

  # Frontend Tests (runs in parallel with backend tests)
  frontend-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        node-version: ["18"]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run frontend tests
        working-directory: ./frontend
        run: npm test -- --coverage --watchAll=false --maxWorkers=2

      - name: Upload frontend coverage
        uses: codecov/codecov-action@v3
        if: always() && github.event_name != 'pull_request'
        with:
          file: ./frontend/coverage/lcov.info
          flags: frontend
          name: frontend-coverage
          fail_ci_if_error: false
          verbose: true
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload frontend coverage artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-coverage-reports
          path: |
            frontend/coverage/
          retention-days: 30

  # Dependency Scanning (runs in parallel)
  dependency-scan:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Scan Python dependencies
        run: |
          pip install safety
          safety check --json --output safety-report.json || true
          echo "Python dependency scan completed"

      - name: Scan Node.js dependencies
        working-directory: ./frontend
        run: |
          npm audit --audit-level moderate --json > npm-audit.json || true
          echo "Node.js dependency scan completed"

      - name: Upload dependency scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dependency-scan-results
          path: |
            safety-report.json
            frontend/npm-audit.json

  # Terraform Plan (runs independently to ensure it always generates the plan)
  terraform-plan:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-west-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Cache Terraform
        uses: actions/cache@v3
        with:
          path: |
            .terraform
            .terraform.lock.hcl
          key: ${{ runner.os }}-terraform-${{ hashFiles('terraform/**/*.tf') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Determine Environment
        id: env
        run: |
          # Determine environment based on branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prod"
          elif [[ "${{ github.ref }}" =~ refs/heads/dev[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" =~ refs/heads/qa[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" =~ refs/heads/staging[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" =~ refs/heads/hotfix[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          else
            ENVIRONMENT="dev"
          fi

          MAIN_ENV=$(echo $ENVIRONMENT | sed 's/[0-9]*$//')

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "main_env=$MAIN_ENV" >> $GITHUB_OUTPUT
          echo "is_sub_env=$([[ "$ENVIRONMENT" =~ [0-9]+$ ]] && echo "true" || echo "false")" >> $GITHUB_OUTPUT

          echo "Planning for environment: $ENVIRONMENT"
          echo "Main environment: $MAIN_ENV"
          echo "Is sub-environment: ${{ steps.env.outputs.is_sub_env }}"

      - name: Terraform Init
        run: |
          cd terraform/environments/${{ steps.env.outputs.main_env }}
          echo "Initializing Terraform in terraform/environments/${{ steps.env.outputs.main_env }}"

          # Test AWS credentials
          echo "Testing AWS credentials..."
          aws sts get-caller-identity

          # Initialize Terraform
          terraform init

          # List current directory
          echo "Current directory contents:"
          ls -la

      - name: Terraform Plan
        run: |
          cd terraform/environments/${{ steps.env.outputs.main_env }}

          # Get ECR registry URL for variables
          echo "Getting AWS account ID..."
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          echo "Using ECR registry: $ECR_REGISTRY"
          echo "Planning for environment: ${{ steps.env.outputs.environment }}"
          echo "Main environment: ${{ steps.env.outputs.main_env }}"
          echo "Is sub-environment: ${{ steps.env.outputs.is_sub_env }}"

          # Plan with sub-environment variable if it's a sub-environment
          if [[ "${{ steps.env.outputs.is_sub_env }}" == "true" ]]; then
            echo "Planning for sub-environment: ${{ steps.env.outputs.environment }}"
            terraform plan -out=tfplan \
              -var="sub_environment=${{ steps.env.outputs.environment }}" \
              -var="ecr_repository_url=${ECR_REGISTRY}/dpp-backend" \
              -var="frontend_ecr_repository_url=${ECR_REGISTRY}/dpp-frontend" \
              -var="image_tag=latest" \
              -var="frontend_image_tag=latest" \
              -detailed-exitcode
          else
            echo "Planning for main environment: ${{ steps.env.outputs.environment }}"
            terraform plan -out=tfplan \
              -var="ecr_repository_url=${ECR_REGISTRY}/dpp-backend" \
              -var="frontend_ecr_repository_url=${ECR_REGISTRY}/dpp-frontend" \
              -var="image_tag=latest" \
              -var="frontend_image_tag=latest" \
              -detailed-exitcode
          fi

          # Check exit code
          PLAN_EXIT_CODE=$?
          echo "Terraform plan exit code: $PLAN_EXIT_CODE"

          # Exit code 0 = success, 1 = error, 2 = changes detected
          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "✅ Terraform plan completed successfully (no changes)"
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "✅ Terraform plan completed successfully (changes detected)"
          else
            echo "❌ Terraform plan failed with exit code $PLAN_EXIT_CODE"
            exit 1
          fi

          # Verify the plan file was created
          if [ ! -f "tfplan" ]; then
            echo "❌ Terraform plan file was not created"
            exit 1
          fi

          echo "✅ Terraform plan created successfully"
          ls -la tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ steps.env.outputs.environment }}
          path: terraform/environments/${{ steps.env.outputs.main_env }}/tfplan

  # Quality Gate (runs after all jobs)
  quality-gate:
    runs-on: ubuntu-latest
    needs:
      [
        backend-tests,
        frontend-tests,
        security-scan,
        dependency-scan,
        terraform-plan,
      ]
    if: always()
    steps:
      - name: Check all jobs completed successfully
        run: |
          if [[ "${{ needs.backend-tests.result }}" != "success" ]]; then
            echo "❌ Backend tests failed"
            exit 1
          fi
          if [[ "${{ needs.frontend-tests.result }}" != "success" ]]; then
            echo "❌ Frontend tests failed"
            exit 1
          fi
          if [[ "${{ needs.security-scan.result }}" != "success" ]]; then
            echo "❌ Security scan failed"
            exit 1
          fi
          if [[ "${{ needs.terraform-plan.result }}" != "success" ]]; then
            echo "❌ Terraform plan failed"
            exit 1
          fi
          echo "✅ All quality gates passed"
