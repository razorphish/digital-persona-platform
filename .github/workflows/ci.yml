name: Continuous Integration (Optimized)

on:
  push:
    branches: [main, "dev*", "qa*", "staging*", "hotfix*"]
  pull_request:
    branches: [main, "dev*", "qa*", "staging*", "hotfix*"]

permissions:
  security-events: write
  actions: read
  contents: read

env:
  AWS_REGION: us-west-1
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "18"

# Prevent multiple CI runs from conflicting
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Security Scanning (runs in parallel with tests)
  security-scan:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for secret scanning

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: Run Secret Scanner
        uses: trufflesecurity/trufflehog@main
        with:
          path: .
          base: HEAD~1
          head: HEAD

  # Backend Tests (runs in parallel with frontend tests)
  backend-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        python-version: ["3.11"]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            ~/.cache/pytest
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}-${{ matrix.python-version }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}-
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio pytest-xdist

      - name: Run backend tests with coverage
        run: |
          python -m pytest tests/ -v --cov=app --cov-report=xml --cov-report=term-missing -n auto

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: backend
          name: backend-coverage
          fail_ci_if_error: false

  # Frontend Tests (runs in parallel with backend tests)
  frontend-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        node-version: ["18"]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run frontend tests
        working-directory: ./frontend
        run: npm test -- --coverage --watchAll=false --maxWorkers=2

      - name: Upload frontend coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./frontend/coverage/lcov.info
          flags: frontend
          name: frontend-coverage
          fail_ci_if_error: false

  # Dependency Scanning (runs in parallel)
  dependency-scan:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Scan Python dependencies
        run: |
          pip install safety
          safety check --json --output safety-report.json || true
          echo "Python dependency scan completed"

      - name: Scan Node.js dependencies
        working-directory: ./frontend
        run: |
          npm audit --audit-level moderate --json > npm-audit.json || true
          echo "Node.js dependency scan completed"

      - name: Upload dependency scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dependency-scan-results
          path: |
            safety-report.json
            frontend/npm-audit.json

  # Terraform Plan (runs after tests complete)
  terraform-plan:
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests, security-scan]
    timeout-minutes: 20
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-west-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Cache Terraform
        uses: actions/cache@v3
        with:
          path: |
            .terraform
            .terraform.lock.hcl
          key: ${{ runner.os }}-terraform-${{ hashFiles('terraform/**/*.tf') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Determine Environment
        id: env
        run: |
          # Determine environment based on branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prod"
          elif [[ "${{ github.ref }}" =~ refs/heads/dev[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" =~ refs/heads/qa[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" =~ refs/heads/staging[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" =~ refs/heads/hotfix[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          else
            ENVIRONMENT="dev"
          fi

          MAIN_ENV=$(echo $ENVIRONMENT | sed 's/[0-9]*$//')

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "main_env=$MAIN_ENV" >> $GITHUB_OUTPUT
          echo "is_sub_env=$([[ "$ENVIRONMENT" =~ [0-9]+$ ]] && echo "true" || echo "false")" >> $GITHUB_OUTPUT

          echo "Planning for environment: $ENVIRONMENT"
          echo "Main environment: $MAIN_ENV"
          echo "Is sub-environment: ${{ steps.env.outputs.is_sub_env }}"

      - name: Set up Terraform workspace for planning
        run: |
          MAIN_ENV="${{ steps.env.outputs.main_env }}"
          SUB_ENV="${{ steps.env.outputs.environment }}"

          echo "Setting up workspace for planning: $SUB_ENV"
          echo "Main environment: $MAIN_ENV"

          cd terraform/environments/$MAIN_ENV

          # Create/select workspace for planning
          if terraform workspace list | grep -q "$SUB_ENV"; then
            echo "Workspace $SUB_ENV exists, selecting it"
            terraform workspace select "$SUB_ENV"
          else
            echo "Creating new workspace for planning: $SUB_ENV"
            terraform workspace new "$SUB_ENV"
          fi

      - name: Terraform Init
        run: |
          cd terraform/environments/${{ steps.env.outputs.main_env }}
          terraform init

      - name: Terraform Plan
        run: |
          cd terraform/environments/${{ steps.env.outputs.main_env }}

          # Plan with sub-environment variable if it's a sub-environment
          if [[ "${{ steps.env.outputs.is_sub_env }}" == "true" ]]; then
            echo "Planning for sub-environment: ${{ steps.env.outputs.environment }}"
            terraform plan -out=tfplan -var="sub_environment=${{ steps.env.outputs.environment }}"
          else
            echo "Planning for main environment: ${{ steps.env.outputs.environment }}"
            terraform plan -out=tfplan
          fi

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ steps.env.outputs.environment }}
          path: terraform/environments/${{ steps.env.outputs.main_env }}/tfplan

  # Quality Gate (runs after all jobs)
  quality-gate:
    runs-on: ubuntu-latest
    needs:
      [
        backend-tests,
        frontend-tests,
        security-scan,
        dependency-scan,
        terraform-plan,
      ]
    if: always()
    steps:
      - name: Check all jobs completed successfully
        run: |
          if [[ "${{ needs.backend-tests.result }}" != "success" ]]; then
            echo "❌ Backend tests failed"
            exit 1
          fi
          if [[ "${{ needs.frontend-tests.result }}" != "success" ]]; then
            echo "❌ Frontend tests failed"
            exit 1
          fi
          if [[ "${{ needs.security-scan.result }}" != "success" ]]; then
            echo "❌ Security scan failed"
            exit 1
          fi
          if [[ "${{ needs.terraform-plan.result }}" != "success" ]]; then
            echo "❌ Terraform plan failed"
            exit 1
          fi
          echo "✅ All quality gates passed"
