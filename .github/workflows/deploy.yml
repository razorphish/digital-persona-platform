name: Deploy (Optimized)

on:
  workflow_run:
    workflows: ["Continuous Integration (Optimized)"]
    types:
      - completed
    branches: ["dev*", "qa*", "staging*", "hotfix*"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "prod"
        type: choice
        options:
          - dev
          - dev01
          - dev02
          - dev03
          - qa
          - qa01
          - qa02
          - qa03
          - staging
          - staging01
          - staging02
          - staging03
          - hotfix
          - hotfix01
          - hotfix02
          - hotfix03
          - prod
      force_deploy:
        description: "Force deployment even if tests fail"
        required: false
        default: false
        type: boolean
      rollback_on_failure:
        description: "Automatically rollback on deployment failure"
        required: false
        default: true
        type: boolean

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-west-1
  DOMAIN: hibiji.com

# Prevent multiple deployments to the same environment
concurrency:
  group: deploy-${{ github.event.inputs.environment || 'prod' }}
  cancel-in-progress: false

jobs:
  # Pre-deployment validation
  validate:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine Environment
        id: env
        run: |
          # Determine environment based on workflow_run context or manual input
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            # Get the branch from the triggering workflow
            BRANCH_NAME="${{ github.event.workflow_run.head_branch }}"
          else
            # Manual dispatch
            BRANCH_NAME="${{ github.ref_name }}"
          fi

          # Determine environment based on branch
          if [[ "$BRANCH_NAME" == "main" ]]; then
            ENVIRONMENT="prod"
          elif [[ "$BRANCH_NAME" =~ ^dev[0-9]+$ ]]; then
            ENVIRONMENT="$BRANCH_NAME"
          elif [[ "$BRANCH_NAME" =~ ^qa[0-9]+$ ]]; then
            ENVIRONMENT="$BRANCH_NAME"
          elif [[ "$BRANCH_NAME" =~ ^staging[0-9]+$ ]]; then
            ENVIRONMENT="$BRANCH_NAME"
          elif [[ "$BRANCH_NAME" =~ ^hotfix[0-9]+$ ]]; then
            ENVIRONMENT="$BRANCH_NAME"
          elif [[ "$BRANCH_NAME" == "dev" ]]; then
            ENVIRONMENT="dev"
          elif [[ "$BRANCH_NAME" == "qa" ]]; then
            ENVIRONMENT="qa"
          elif [[ "$BRANCH_NAME" == "staging" ]]; then
            ENVIRONMENT="staging"
          else
            ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          fi

          MAIN_ENV=$(echo $ENVIRONMENT | sed 's/[0-9]*$//')

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "main_env=$MAIN_ENV" >> $GITHUB_OUTPUT
          echo "is_sub_env=$([[ "$ENVIRONMENT" =~ [0-9]+$ ]] && echo "true" || echo "false")" >> $GITHUB_OUTPUT

          echo "Deploying to environment: $ENVIRONMENT"
          echo "Main environment: $MAIN_ENV"
          echo "Is sub-environment: ${{ steps.env.outputs.is_sub_env }}"

      - name: Validate environment input
        run: |
          ENVIRONMENT="${{ steps.env.outputs.environment }}"
          echo "Validating deployment to: $ENVIRONMENT"

          # Validate environment format
          if [[ ! "$ENVIRONMENT" =~ ^(dev|qa|staging|hotfix|prod)([0-9]+)?$ ]]; then
            echo "‚ùå Invalid environment: $ENVIRONMENT"
            exit 1
          fi

          echo "‚úÖ Environment validation passed"

      - name: Check Terraform plan exists
        uses: actions/download-artifact@v4
        if: github.event_name == 'workflow_run'
        with:
          name: terraform-plan-${{ steps.env.outputs.environment }}
          path: /tmp/terraform-plan
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Find latest CI run for manual trigger
        if: github.event_name == 'workflow_dispatch'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Find the most recent successful CI run from the same branch
          CURRENT_BRANCH="${{ github.ref_name }}"
          echo "Looking for CI runs from branch: $CURRENT_BRANCH"

          # Get CI runs and filter by branch and success status
          LATEST_CI_RUN=$(gh run list --workflow="Continuous Integration (Optimized)" --json databaseId,conclusion,headBranch --limit 20 | jq -r ".[] | select(.conclusion == \"success\" and .headBranch == \"$CURRENT_BRANCH\") | .databaseId" | head -1)

          if [ -z "$LATEST_CI_RUN" ]; then
            echo "‚ùå No successful CI run found for branch $CURRENT_BRANCH. Run CI first."
            exit 1
          fi
          echo "CI_RUN_ID=$LATEST_CI_RUN" >> $GITHUB_ENV
          echo "Using CI run ID: $LATEST_CI_RUN from branch $CURRENT_BRANCH"

      - name: Download Terraform plan from latest CI run
        uses: actions/download-artifact@v4
        if: github.event_name == 'workflow_dispatch'
        with:
          name: terraform-plan-${{ steps.env.outputs.environment }}
          path: /tmp/terraform-plan
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ env.CI_RUN_ID }}

      - name: Verify Terraform plan
        run: |
          echo "Checking for Terraform plan in /tmp/terraform-plan/"
          ls -la /tmp/terraform-plan/ || echo "Directory does not exist"

          if [ ! -f "/tmp/terraform-plan/tfplan" ]; then
            echo "‚ùå Terraform plan not found. Run CI first."
            echo "Expected file: /tmp/terraform-plan/tfplan"
            echo "Current directory contents:"
            ls -la /tmp/ || echo "No /tmp directory"
            exit 1
          fi
          echo "‚úÖ Terraform plan found"
          ls -la /tmp/terraform-plan/tfplan

  # Build and Deploy
  deploy:
    runs-on: ubuntu-latest
    needs: [validate]
    if: github.ref == 'refs/heads/dev*' || github.ref == 'refs/heads/qa*' || github.ref == 'refs/heads/staging*' || github.ref == 'refs/heads/hotfix*' || github.event.inputs.force_deploy == 'true'
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine Environment
        id: env
        run: |
          # Determine environment based on workflow_run context or manual input
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            # Get the branch from the triggering workflow
            BRANCH_NAME="${{ github.event.workflow_run.head_branch }}"
          else
            # Manual dispatch
            BRANCH_NAME="${{ github.ref_name }}"
          fi

          # Determine environment based on branch
          if [[ "$BRANCH_NAME" == "main" ]]; then
            ENVIRONMENT="prod"
          elif [[ "$BRANCH_NAME" =~ ^dev[0-9]+$ ]]; then
            ENVIRONMENT="$BRANCH_NAME"
          elif [[ "$BRANCH_NAME" =~ ^qa[0-9]+$ ]]; then
            ENVIRONMENT="$BRANCH_NAME"
          elif [[ "$BRANCH_NAME" =~ ^staging[0-9]+$ ]]; then
            ENVIRONMENT="$BRANCH_NAME"
          elif [[ "$BRANCH_NAME" =~ ^hotfix[0-9]+$ ]]; then
            ENVIRONMENT="$BRANCH_NAME"
          elif [[ "$BRANCH_NAME" == "dev" ]]; then
            ENVIRONMENT="dev"
          elif [[ "$BRANCH_NAME" == "qa" ]]; then
            ENVIRONMENT="qa"
          elif [[ "$BRANCH_NAME" == "staging" ]]; then
            ENVIRONMENT="staging"
          else
            ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          fi

          MAIN_ENV=$(echo $ENVIRONMENT | sed 's/[0-9]*$//')

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "main_env=$MAIN_ENV" >> $GITHUB_OUTPUT
          echo "is_sub_env=$([[ "$ENVIRONMENT" =~ [0-9]+$ ]] && echo "true" || echo "false")" >> $GITHUB_OUTPUT

          echo "Deploying to environment: $ENVIRONMENT"
          echo "Main environment: $MAIN_ENV"
          echo "Is sub-environment: ${{ steps.env.outputs.is_sub_env }}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-west-1

      - name: Get ECR Registry URL
        id: ecr
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          echo "registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT
          echo "Using ECR registry: $ECR_REGISTRY"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend image
        id: backend-build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/dpp-backend:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/dpp-backend:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          platforms: linux/amd64

      - name: Build and push frontend image
        id: frontend-build
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/dpp-frontend:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/dpp-frontend:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          platforms: linux/amd64

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        if: github.event_name == 'workflow_run'
        with:
          name: terraform-plan-${{ steps.env.outputs.environment }}
          path: terraform/environments/${{ steps.env.outputs.main_env }}/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Download Terraform Plan from latest CI run
        uses: actions/download-artifact@v4
        if: github.event_name == 'workflow_dispatch'
        with:
          name: terraform-plan-${{ steps.env.outputs.environment }}
          path: terraform/environments/${{ steps.env.outputs.main_env }}/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ env.CI_RUN_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Set up Terraform workspace and tfvars
        run: |
          MAIN_ENV="${{ steps.env.outputs.main_env }}"
          SUB_ENV="${{ steps.env.outputs.environment }}"
          TFVARS_FILE="terraform/environments/$MAIN_ENV/${SUB_ENV}.auto.tfvars"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          echo "Setting up workspace and tfvars for sub-environment: $SUB_ENV"
          echo "Main environment: $MAIN_ENV"
          echo "Tfvars file: $TFVARS_FILE"

          # 1. Create/select workspace
          cd terraform/environments/$MAIN_ENV
          echo "Checking for existing workspace: $SUB_ENV"
          if terraform workspace list | grep -q "$SUB_ENV"; then
            echo "Workspace $SUB_ENV exists, selecting it"
            terraform workspace select "$SUB_ENV"
          else
            echo "Creating new workspace: $SUB_ENV"
            terraform workspace new "$SUB_ENV"
          fi

          # 2. Generate tfvars file if missing
          if [ ! -f "$TFVARS_FILE" ]; then
            echo "Generating $TFVARS_FILE from template"
            sed \
              -e "s/{{MAIN_ENV}}/$MAIN_ENV/g" \
              -e "s/{{SUB_ENV}}/$SUB_ENV/g" \
              -e "s/{{TIMESTAMP}}/$TIMESTAMP/g" \
              -e "s/{{BRANCH_NAME}}/${{ github.ref_name }}/g" \
              -e "s|{{ECR_BACKEND_URL}}|${{ steps.login-ecr.outputs.registry }}/dpp-backend|g" \
              -e "s|{{ECR_FRONTEND_URL}}|${{ steps.login-ecr.outputs.registry }}/dpp-frontend|g" \
              -e "s/{{IMAGE_TAG}}/${{ github.sha }}/g" \
              -e "s/{{FRONTEND_IMAGE_TAG}}/${{ github.sha }}/g" \
              ../../tfvars.template > "$TFVARS_FILE"
            
            echo "Generated tfvars file:"
            cat "$TFVARS_FILE"
          else
            echo "Tfvars file $TFVARS_FILE already exists"
          fi

          # 3. Verify workspace is selected
          CURRENT_WORKSPACE=$(terraform workspace show)
          echo "Current workspace: $CURRENT_WORKSPACE"
          if [ "$CURRENT_WORKSPACE" != "$SUB_ENV" ]; then
            echo "‚ùå Error: Expected workspace $SUB_ENV, but current workspace is $CURRENT_WORKSPACE"
            exit 1
          fi

      - name: Terraform Apply
        id: terraform
        run: |
          cd terraform/environments/${{ steps.env.outputs.main_env }}

          # Apply with sub-environment variable if it's a sub-environment
          if [[ "${{ steps.env.outputs.is_sub_env }}" == "true" ]]; then
            echo "Deploying to sub-environment: ${{ steps.env.outputs.environment }}"
            terraform apply -auto-approve tfplan \
              -var="sub_environment=${{ steps.env.outputs.environment }}" \
              -var="ecr_repository_url=${{ steps.login-ecr.outputs.registry }}/dpp-backend:${{ github.sha }}" \
              -var="frontend_ecr_repository_url=${{ steps.login-ecr.outputs.registry }}/dpp-frontend:${{ github.sha }}" \
              -var="image_tag=${{ github.sha }}" \
              -var="frontend_image_tag=${{ github.sha }}"
          else
            echo "Deploying to main environment: ${{ steps.env.outputs.environment }}"
            terraform apply -auto-approve tfplan
          fi

      - name: Extract Environment Variables
        id: env_vars
        run: |
          # Determine environment based on branch or manual input
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prod"
          elif [[ "${{ github.ref }}" =~ refs/heads/dev[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed "s/^refs/heads///")
          elif [[ "${{ github.ref }}" =~ refs/heads/qa[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed "s/^refs/heads///")
          elif [[ "${{ github.ref }}" =~ refs/heads/staging[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed "s/^refs/heads///")
          elif [[ "${{ github.ref }}" =~ refs/heads/hotfix[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed "s/^refs/heads///")
          elif [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            ENVIRONMENT="dev"
          elif [[ "${{ github.ref }}" == "refs/heads/qa" ]]; then
            ENVIRONMENT="qa"
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            ENVIRONMENT="staging"
          else
            ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          fi

          # Extract main environment (remove numbers)
          MAIN_ENV=$(echo $ENVIRONMENT | sed "s/[0-9]*$//")

          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
          echo "MAIN_ENV=$MAIN_ENV" >> $GITHUB_ENV
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "main_env=$MAIN_ENV" >> $GITHUB_OUTPUT

          echo "Deploying to environment: $ENVIRONMENT"
          echo "Main environment: $MAIN_ENV"
      - name: Update ECS services
        run: |
          # Update backend service
          aws ecs update-service \
            --cluster hibiji-${{ env.ENVIRONMENT }}-cluster \
            --service hibiji-${{ env.ENVIRONMENT }}-backend \
            --force-new-deployment

          # Update frontend service
          aws ecs update-service \
            --cluster hibiji-${{ env.ENVIRONMENT }}-cluster \
            --service hibiji-${{ env.ENVIRONMENT }}-frontend \
            --force-new-deployment

      - name: Wait for deployment
        run: |
          # Wait for backend service to stabilize
          aws ecs wait services-stable \
            --cluster hibiji-${{ env.ENVIRONMENT }}-cluster \
            --services hibiji-${{ env.ENVIRONMENT }}-backend

          # Wait for frontend service to stabilize
          aws ecs wait services-stable \
            --cluster hibiji-${{ env.ENVIRONMENT }}-cluster \
            --services hibiji-${{ env.ENVIRONMENT }}-frontend

  # Health Check
  health-check:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: github.ref == 'refs/heads/dev*' || github.ref == 'refs/heads/qa*' || github.ref == 'refs/heads/staging*' || github.ref == 'refs/heads/hotfix*' || github.event.inputs.force_deploy == 'true'
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-west-1

      - name: Health check
        run: |
          # Determine the domain based on environment
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prod"
          elif [[ "${{ github.ref }}" =~ refs/heads/dev[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" =~ refs/heads/qa[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" =~ refs/heads/staging[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" =~ refs/heads/hotfix[0-9]+ ]]; then
            ENVIRONMENT=$(echo "${{ github.ref_name }}" | sed 's/^refs\/heads\///')
          elif [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            ENVIRONMENT="dev"
          elif [[ "${{ github.ref }}" == "refs/heads/qa" ]]; then
            ENVIRONMENT="qa"
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            ENVIRONMENT="staging"
          else
            ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          fi

          if [[ "$ENVIRONMENT" =~ [0-9]+$ ]]; then
            # Sub-environment: dev22 -> dev22.hibiji.com, hotfix01 -> hotfix01.hibiji.com
            DOMAIN="$ENVIRONMENT.${{ env.DOMAIN }}"
          else
            # Main environment: dev -> dev.hibiji.com, hotfix -> hotfix.hibiji.com, or prod -> hibiji.com
            if [[ "$ENVIRONMENT" == "prod" ]]; then
              DOMAIN="${{ env.DOMAIN }}"
            else
              DOMAIN="$ENVIRONMENT.${{ env.DOMAIN }}"
            fi
          fi

          echo "Performing health checks for: $DOMAIN"

          # Wait for DNS propagation and service availability
          echo "Waiting for service to become available..."
          for i in {1..15}; do
            echo "Attempt $i/15: Checking if service is available..."
            
            if curl -fs --max-time 10 https://$DOMAIN/health >/dev/null 2>&1; then
              echo "‚úÖ Health endpoint available at https://$DOMAIN/health"
              break
            else
              echo "‚è≥ Service not ready yet..."
              if [ $i -eq 15 ]; then
                echo "‚ùå Service did not become available within timeout"
                exit 1
              fi
              sleep 30
            fi
          done

          # Additional health checks
          echo "Testing API health endpoint..."
          curl -f --max-time 30 https://$DOMAIN/api/health || echo "API health check failed"

          echo "‚úÖ Health checks completed for $DOMAIN"

  # Rollback job (runs on failure)
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: failure() && github.event.inputs.rollback_on_failure == 'true'
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-west-1

      - name: Rollback ECS services
        run: |
          echo "üö® Rolling back deployment due to failure..."

          # Rollback to previous version
          aws ecs update-service \
            --cluster hibiji-${{ env.ENVIRONMENT }}-cluster \
            --service hibiji-${{ env.ENVIRONMENT }}-backend \
            --force-new-deployment

          aws ecs update-service \
            --cluster hibiji-${{ env.ENVIRONMENT }}-cluster \
            --service hibiji-${{ env.ENVIRONMENT }}-frontend \
            --force-new-deployment

          echo "‚úÖ Rollback initiated"

      - name: Notify rollback
        run: |
          echo "üö® DEPLOYMENT FAILED - ROLLBACK INITIATED üö®"
          echo "Environment: ${{ github.event.inputs.environment || 'prod' }}"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "Time: $(date)"
